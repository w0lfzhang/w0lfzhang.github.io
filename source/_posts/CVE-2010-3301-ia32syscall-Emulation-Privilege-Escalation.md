---
title: 'CVE-2010-3301: ia32syscall Emulation Privilege Escalation'
date: 2017-09-28 15:43:21
tags:
- ia32syscall
- privilege escalation
categories:
- cve_analysis
---

## Analysis
分析linux内核的洞老套路先看看漏洞描述：
The IA32 system call emulation functionality in arch/x86/ia32/ia32entry.S in the Linux kernel before 2.6.36-rc4-git2 on the x86_64 platform does not zero extend the %eax register after the 32-bit entry path to ptrace is used, which allows local users to gain privileges by triggering an out-of-bounds access to the system call table using the %rax register. NOTE: this vulnerability exists because of a CVE-2007-4573 regression.
<!-- more -->
注意后面的描述：这个漏洞是因为[CVE-2007-4573](http://cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2007-4573)的regression而存在的，可以先分析一波CVE-2007-4573。比较简单也就没记录分析过程了。直接看下regression是什么:
CVE-2007-4573的patch：
```c
diff --git a/arch/x86_64/ia32/ia32entry.S b/arch/x86_64/ia32/ia32entry.S
index 9382786..18b2318 100644
--- a/arch/x86_64/ia32/ia32entry.S
+++ b/arch/x86_64/ia32/ia32entry.S
@@ -38,6 +38,18 @@
 	movq	%rax,R8(%rsp)
 	.endm
 
+	.macro LOAD_ARGS32 offset
+	movl \offset(%rsp),%r11d
+	movl \offset+8(%rsp),%r10d
+	movl \offset+16(%rsp),%r9d
+	movl \offset+24(%rsp),%r8d
+	movl \offset+40(%rsp),%ecx
+	movl \offset+48(%rsp),%edx
+	movl \offset+56(%rsp),%esi
+	movl \offset+64(%rsp),%edi
+	movl \offset+72(%rsp),%eax   <== important patch
+	.endm

-  .macro LOAD_ARGS offset
-  movq \offset(%rsp),%r11
-  movq \offset+8(%rsp),%r10
-  movq \offset+16(%rsp),%r9
-  movq \offset+24(%rsp),%r8
-  movq \offset+40(%rsp),%rcx
-  movq \offset+48(%rsp),%rdx
-  movq \offset+56(%rsp),%rsi
-  movq \offset+64(%rsp),%rdi
-  movq \offset+72(%rsp),%rax
-  .endm
+	
 	.macro CFI_STARTPROC32 simple
 	CFI_STARTPROC	\simple
 	CFI_UNDEFINED	r8
@@ -152,7 +164,7 @@ sysenter_tracesys:
 	movq	$-ENOSYS,RAX(%rsp)	/* really needed? */
 	movq	%rsp,%rdi        /* &pt_regs -> arg1 */
 	call	syscall_trace_enter
-	LOAD_ARGS ARGOFFSET  /* reload args from stack in case ptrace changed it */
+	LOAD_ARGS32 ARGOFFSET  /* reload args from stack in case ptrace changed it */
 	RESTORE_REST
 	movl	%ebp, %ebp
```
在x86_64下，movl xx，%eax指令会把rax的高32位清零，所以在x86_64下进行32位的系统调用以上补丁是可行的。但是在后来的某个版后，移除了movl \offset+72(%rsp),%eax这条指令：
```c
    /*
	 * Reload arg registers from stack in case ptrace changed them.
	 * We don't reload %eax because syscall_trace_enter() returned
	 * the value it wants us to use in the table lookup.
	 */
	.macro LOAD_ARGS32 offset, _r9=0
	.if \_r9
	movl \offset+16(%rsp),%r9d
	.endif
	movl \offset+40(%rsp),%ecx
	movl \offset+48(%rsp),%edx
	movl \offset+56(%rsp),%esi
	movl \offset+64(%rsp),%edi
	.endm
```
虽然说在大部分情况下是没问题的，但是也不排除某些情况下是有问题的！
再来看下CVE-2010-3301的patch：
```c
diff --git a/arch/x86/ia32/ia32entry.S b/arch/x86/ia32/ia32entry.S
index b86feab..84e3a4e 100644
--- a/arch/x86/ia32/ia32entry.S
+++ b/arch/x86/ia32/ia32entry.S
@@ -153,7 +153,7 @@ ENTRY(ia32_sysenter_target)
 	testl  $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%r10)
 	CFI_REMEMBER_STATE
 	jnz  sysenter_tracesys
-	cmpl	$(IA32_NR_syscalls-1),%eax
+	cmpq	$(IA32_NR_syscalls-1),%rax
 	ja	ia32_badsys
 sysenter_do_call:
 	IA32_ARG_FIXUP
@@ -195,7 +195,7 @@ sysexit_from_sys_call:
 	movl $AUDIT_ARCH_I386,%edi	/* 1st arg: audit arch */
 	call audit_syscall_entry
 	movl RAX-ARGOFFSET(%rsp),%eax	/* reload syscall number */
-	cmpl $(IA32_NR_syscalls-1),%eax
+	cmpq $(IA32_NR_syscalls-1),%rax
 	ja ia32_badsys
 	movl %ebx,%edi			/* reload 1st syscall arg */
 	movl RCX-ARGOFFSET(%rsp),%esi	/* reload 2nd syscall arg */
@@ -248,7 +248,7 @@ sysenter_tracesys:
 	call	syscall_trace_enter
 	LOAD_ARGS32 ARGOFFSET  /* reload args from stack in case ptrace changed it */
 	RESTORE_REST
-	cmpl	$(IA32_NR_syscalls-1),%eax
+	cmpq	$(IA32_NR_syscalls-1),%rax
 	ja	int_ret_from_sys_call /* sysenter_tracesys has set RAX(%rsp) */
 	jmp	sysenter_do_call
 	CFI_ENDPROC
@@ -314,7 +314,7 @@ ENTRY(ia32_cstar_target)
 	testl $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%r10)
 	CFI_REMEMBER_STATE
 	jnz   cstar_tracesys
-	cmpl $IA32_NR_syscalls-1,%eax
+	cmpq $IA32_NR_syscalls-1,%rax
 	ja  ia32_badsys
 cstar_do_call:
 	IA32_ARG_FIXUP 1
@@ -367,7 +367,7 @@ cstar_tracesys:
 	LOAD_ARGS32 ARGOFFSET, 1  /* reload args from stack in case ptrace changed it */
 	RESTORE_REST
 	xchgl %ebp,%r9d
-	cmpl $(IA32_NR_syscalls-1),%eax
+	cmpq $(IA32_NR_syscalls-1),%rax
 	ja int_ret_from_sys_call /* cstar_tracesys has set RAX(%rsp) */
 	jmp cstar_do_call
 END(ia32_cstar_target)
@@ -425,7 +425,7 @@ ENTRY(ia32_syscall)
 	orl   $TS_COMPAT,TI_status(%r10)
 	testl $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%r10)
 	jnz ia32_tracesys
-	cmpl $(IA32_NR_syscalls-1),%eax
+	cmpq $(IA32_NR_syscalls-1),%rax
 	ja ia32_badsys
 ia32_do_call:
 	IA32_ARG_FIXUP
@@ -444,7 +444,7 @@ ia32_tracesys:
 	call syscall_trace_enter
 	LOAD_ARGS32 ARGOFFSET  /* reload args from stack in case ptrace changed it */
 	RESTORE_REST
-	cmpl $(IA32_NR_syscalls-1),%eax
+	cmpq $(IA32_NR_syscalls-1),%rax
 	ja  int_ret_from_sys_call	/* ia32_tracesys has set RAX(%rsp) */
 	jmp ia32_do_call
 END(ia32_syscall)
```
所以从补丁看出是rax的问题：rax的高32位没有清零，那在访问ia32_sys_call_table就会越界，很有可能直接访问用户空间的地址。
```c
ia32_do_call:
	IA32_ARG_FIXUP
	call *ia32_sys_call_table(,%rax,8) # xxx: rip relative
```
首先得知道rax的高32位一般是清零了的，那在什么情况下rax的高32位不会清零？直接修改？对的，利用ptrace修改rax的值！

## ptrace syscall
想要利用这个漏洞，还是先得了解一下ptrace系统调用。这个系统调用平时用的还是挺广泛的吧，像gdb，strace等都是用到了ptrace这个系统调用。
```c
long ptrace(enum __ptrace_request request,
            pid_t pid,
            void *addr,
            void *data);
```
enum __ptrace_request request：指示了ptrace要执行的命令。
pid_t pid: 指示ptrace要跟踪的进程。
void *addr: 指示要监控的内存地址。
void *data: 存放读取出的或者要写入的数据。

主要是要了解request命令的种类，比较多。比较常见的有：
```c
PTRACE_TRACEME： 进程被父进程traced。
PTRACE_PEEKUSER: 读取寄存器的值等。
PTRACE_POKEUSER：修改寄存器的值等。
PTRACE_CONT：    Restart the stopped tracee process。
PTRACE_SYSCALL： Restart the stopped tracee as for PTRACE_CONT, but arrange for the tracee to be stopped at the next entry to or exit from a system call, or after execution of a single instruction, respectively。
```

虽然自己很难把exp给写出来，但是还是涨了姿势。虽然分析比较简单，但中间看源码，理解源码花了不少时间。
```shell
w0lfzhang@w0lfzhang-666:~/Desktop/CVE-2010-3301$ ./pwn
resolved symbol commit_creds to 0xffffffff81085e80
resolved symbol prepare_kernel_cred to 0xffffffff81086260
mapping at 3f80000000
UID 0, EUID:0 GID:0, EGID:0
# id
uid=0(root) gid=0(root)
# 
```
每次分析内核的洞真的能学到很多：对linux内核的运行机制更加熟悉，不管是网络子系统，内存子系统，文件系统等方面都比原来只在内核书籍上看的要理解的更深刻，因为几乎是在看源码，参考资料更是少得可怜，得自己根据源码去理解，去钻研。

## Links
[Anatomy of a system call, part 2](https://lwn.net/Articles/604515/)
[[译] 玩转ptrace (一)](http://www.cnblogs.com/catch/p/3476280.html)
[Patch of CVE-2007-4573](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=176df2457ef6207156ca1a40991c54ca01fef567)