---
title: Starting kernel exploit--Prepared Knowledge
date: 2017-04-25 10:55:28
tags:
- kernel basis
categories:
- kernel_exploit
---

今天开始好好搞kernel exploit。
## Inline assembly
基本形式： 
```asm
asm [ volatile ] (  
    assembler template
    [ : output operands ]  ()               /* optional */
    [ : input operands  ]  ()              /* optional */
    [ : list of clobbered registers ]  ()   /* optional */
    );
```
圆括号中的是约束条件。对输出操作数来说，'='表示'只写；'&'表示这是一个已经被修改过的操作数。%%reg表示引用寄存器的值。
所有参数从0看是编号。%0表示第一个参数，%n-1表示第n个参数。注意是在asm里面声明的输入操作数和输出操作数。
<!-- more -->
约束条件指明怎么使用操作数。
```
R General register (EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP)
q General register for data (EAX, EBX, ECX, EDX)
f Floating-point register
t Top floating-point register
u Second-from-top floating-point register
a EAX register
b EBX register
c ECX register
d EDX register
r q and ESI, EDI register
x SSE register (Streaming SIMD Extension register)
y MMX multimedia registers
A An 8-byte value formed from EAX and EDX
D Destination pointer for string operations (EDI)
S Source pointer for string operations (ESI)
```

### Example
```c
int main()
{
	int ee = 0x4000, ce = 0x8000, reg;
	asm volatile(
		"movl %1, %%eax;"      //eax = ce
		"movl %2, %%ebx;"      //ebx = ee
		"movl %%eax, %0"       //reg = eax
		: "=r" (reg)  		   //%0
		: "r"  (ce), "r" (ee)  //%1, %2
		: "%eax", "%ebx"
	)
	printf("reg = %x", reg);
	return 0;
}
```
相应的汇编代码如下：
```asm
   0x400536 <main+9>:	mov    DWORD PTR [rbp-0x1c],0x4000
   0x40053d <main+16>:	mov    DWORD PTR [rbp-0x18],0x8000
   0x400544 <main+23>:	mov    edx,DWORD PTR [rbp-0x18]
   0x400547 <main+26>:	mov    ecx,DWORD PTR [rbp-0x1c]
   0x40054a <main+29>:	mov    eax,edx
   0x40054c <main+31>:	mov    ebx,ecx
   0x40054e <main+33>:	mov    edx,eax
   0x400550 <main+35>:	mov    DWORD PTR [rbp-0x14],edx
   0x400553 <main+38>:	mov    eax,DWORD PTR [rbp-0x14]
   0x400556 <main+41>:	mov    esi,eax
   0x400558 <main+43>:	mov    edi,0x400604
   0x40055d <main+48>:	mov    eax,0x0
   0x400562 <main+53>:	call   0x400410 <printf@plt>
```

## Special C usage

### asmlinkage
此关键字告诉编译器将参数存入局部栈中，而不是通过寄存器传参。

### inline
关键字inline表示要优化函数的可执行代码，这可以通过将函数的代码合并到调用的代码中来实现。一个声明为'static inline'的函数促使编译器尝试将其代码合并到所有调用它的程序中。主要是来消除函数调用的任何开销。

### const && volatile
感觉在复习c语言...
```c
const int *x;
int const *x;
```
第一个表示x是指向const整数的指针，指针可以改变，但是这个整数不能改变。
第二个表示x是指向整数的const指针，整数可以改变，但是这个指针不能改变。

volatile表示变量无需警告就可以被修改。

## Kernel Demo
首先构造内核树。我在ubuntu14.04上面构建。
```shell
w0lfzhang@w0lfzhang666:~/Desktop/kernel/linux-3.12$ uname -a
Linux w0lfzhang666 3.13.0-95-generic #142-Ubuntu SMP Fri Aug 12 17:00:09 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux
```
我下了linux-3.13.0的内核，然后cd到该目录下构建。
1. make oldconfig 
2. make
3. make bzImage
4. make modules
5. make module_install

编译完成后会在/lib/modules下生成新的目录3.13.0-generic/。

好吧，系统本来有内核源码树....浪费我时间。
The simple demo:
```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>

MODULE_LICENSE("Dual BSD/GPL");

static int hello_init(void)
{
	printk(KERN_ALERT "Hello, world\n");
	return 0;
}

static void hello_exit(void)
{
	printk(KERN_ALERT "Goodbye, cruel world\n");
}

module_init(hello_init);
module_exit(hello_exit);
```
touch一个Makefile。
```shell
obj-m := hello.o 
KERNELDIR := /lib/modules/3.13.0-95-generic/build
PWD := $(shell pwd) 
modules: 
	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules 
modules_install: 
	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules_install
```
然后make，insmod hello.ko。终端没输出，到/var/log/查看输出记录。
```shell
root@w0lfzhang666:/home/w0lfzhang/Desktop/kernel# cat /var/log/syslog | grep worldApr 25 22:29:50 w0lfzhang666 kernel: [62400.008758] Hello, world
```
过程中总出现以下问题：
```shell
insmod: ERROR: could not insert module hello.ko: Invalid module format
```
原因是使用的内核源码树跟本机不一样..然后我换成本机原来的源码树就可以了。
```shell
3.13.0-32-generic  3.13.0-66-generic  3.13.0-95-generic
```
最后要卸载模块的话rmmod hello即可。
