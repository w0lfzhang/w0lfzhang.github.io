---
title: Linux-Slub-Overflow-Exploit
date: 2017-09-07 19:56:19
tags:
- slub overflow
- shmid_kernel
categories:
- kernel_exploit
---

再探slub--有趣。关于slub的工作原理可参考[这篇文章](http://blog.csdn.net/lukuen/article/details/6935068)，写的真的好！
首先把共享内存函数简单研究一下，因为后面将会用到这方面的东西。

## Shared Memory Functions
共享内存函数由shmget、shmat、shmdt、shmctl四个函数组成，主要用于linux进程间通信。
首先分析下用户态下函数的功能。
<!-- more -->
```c
int shmget(key_t key, size_t size, int shmflg);
```
该函数用来创建共享内存。

```c
void *shmat(int shm_id, const void *shm_addr, int shmflg);
```
第一次创建完共享内存后，它还不能被任何进程访问。shmat()函数的作用就是用来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间。

```c
int shmdt(const void *shmaddr);
```
该函数用于将共享内存从当前进程中分离。注意，将共享内存分离并不是删除它，只是使该共享内存对当前进程不再可用。

```c
int shmctl(int shm_id, int command, struct shmid_ds *buf)；
```
该函数用来控制共享内存，例如得到或改变共享内存的状态，删除共享内存等。

## How to Exploit
实验环境：
```
root@w0lfzhang666:/home/w0lfzhang# uname -a
Linux w0lfzhang666 2.6.32.21 #0 SMP Tue Sep 12 11:11:54 CST 2017 i686 GNU/Linux
root@w0lfzhang666:/home/w0lfzhang# lsb_release -a
No LSB modules are available.
Distributor ID:	Ubuntu
Description:	Ubuntu 10.04 LTS
Release:	10.04
Codename:	lucid
```

slub溢出该怎么利用？其实跟用户态堆溢出相似，终归到底我们还是得劫持内核的执行流。但是怎么利用slub溢出来劫持执行流呢？只要slub分配的结构体中有函数指针就行！然而大部分情况下分配的结构体本身并不包含函数指针，反而其包含的结构体字段中可能含有函数指针。通过溢出我们可以覆盖包含函数指针的结构体为一个fake结构体(如果没有的话就递归伪造fake struct直到某个结构体中有函数指针)，在这个fake struct里我们把某些可控的函数指针覆盖为shellcode的地址，然后触发这个函数执行即可！

而shmid_kernel是一个很好的目标(但并不是唯一！)。只要满足slub溢出的相应条件，也可分配其他大小满足的结构体，利用思路都是差不多的。
```c
/* based on kernel 2.6.32.26 */

struct shmid_kernel /* private to the kernel */
{	
	struct kern_ipc_perm	shm_perm;
	struct file *	shm_file;
	unsigned long	shm_nattch;
	unsigned long	shm_segsz;
	time_t	shm_atim;
	time_t	shm_dtim;
	time_t	shm_ctim;
	pid_t	shm_cprid;
	pid_t	shm_lprid;
	struct user_struct	*mlock_user;

	/* The task created the shm object.  NULL if the task is dead. */
	struct task_struct	*shm_creator;
};

struct kern_ipc_perm
{
	spinlock_t	lock;
	int		deleted;
	int		id;
	key_t		key;
	kuid_t		uid;
	kgid_t		gid;
	kuid_t		cuid;
	kgid_t		cgid;
	umode_t		mode; 
	unsigned long	seq;
	void		*security;
};
```

初步目标很明确，可以覆盖shmid_kernl的shm_file指针，伪造fake file struct，继续在fake file结构体中覆盖f_op指针，伪造fake file_operations。这时困扰我的是就是覆盖哪一个函数指针？这就需要知道内核什么时候会调用file_operations里面的函数。

这是最麻烦又最骚的地方！那又怎样？

其实仔细一想也是，共享内存，肯定得把共享内存区对象映射到进程的地址空间(通过shmat系统调用)。那么mmap函数肯定是得被调用的。

shmat系统调用会通过相关函数得到shmget分配的shmid_kernel结构体。
```c
SYSCALL_DEFINE3(shmat, int, shmid, char __user *, shmaddr, int, shmflg)
{
	......
	err = do_shmat(shmid, shmaddr, shmflg, &ret, SHMLBA);
	......
}

long do_shmat(int shmid, char __user *shmaddr, int shmflg, ulong *raddr,
	      unsigned long shmlba)
{
	struct shmid_kernel *shp;
	......
	shp = shm_obtain_object_check(ns, shmid);  //get allocated shmid_kernel struct
	if (IS_ERR(shp)) {
		err = PTR_ERR(shp);
		goto out_unlock;
	}

	......
	addr = do_mmap_pgoff(file, addr, size, prot, flags, 0, &populate);
	......

}
```
我们伪造的mmap函数指针会在do_mmap_pgoff函数里面被触发。

基本原理都已经搞懂了，现在该想想具体的利用步骤了！这就需要在slub分配原理上做文章了。
因为我们要保证有bug的代码分配的object和我们要覆盖的函数指针所在的object是相邻的(不是必须)，这样才能更好得覆盖相关字段。当一个cache中的所有slab结构中的obj都用完的时候，内核将重新分配slab，而重新分配的slab中的obj彼此都是相邻的。所以我们想办法不断消耗slab直到用完，然后内核就会分配新的slab了。这时就可就需要shaget系统调用了！
shmget系统调用的源码主要是分配shmid_kernel结构体，设置file_operations的函数指针。
[sys_shmget](http://elixir.free-electrons.com/linux/v2.6.32.26/source/ipc/shm.c#L449)函数会在内核空间为shmid_kernel结构体分配内存空间。
```c
/*  sys_shmget->ipcget->ipcget_new->newseg */

SYSCALL_DEFINE3(shmget, key_t, key, size_t, size, int, shmflg)
{
	struct ipc_namespace *ns;
	struct ipc_ops shm_ops;
	......

	shm_ops.getnew = newseg;  <== attetion!!!
	......

	return ipcget(ns, &shm_ids(ns), &shm_ops, &shm_params);
}

int ipcget(struct ipc_namespace *ns, struct ipc_ids *ids,
			struct ipc_ops *ops, struct ipc_params *params)
{
	if (params->key == IPC_PRIVATE)
		return ipcget_new(ns, ids, ops, params);
	else
		return ipcget_public(ns, ids, ops, params);
}

static int ipcget_new(struct ipc_namespace *ns, struct ipc_ids *ids,
		struct ipc_ops *ops, struct ipc_params *params)
{
	int err;
retry:
	err = idr_pre_get(&ids->ipcs_idr, GFP_KERNEL);

	if (!err)
		return -ENOMEM;

	down_write(&ids->rw_mutex);
	err = ops->getnew(ns, params);
	up_write(&ids->rw_mutex);

	if (err == -EAGAIN)
		goto retry;

	return err;
}

static int newseg(struct ipc_namespace *ns, struct ipc_params *params)
{
	......
	struct shmid_kernel *shp;
	......

	shp = ipc_rcu_alloc(sizeof(*shp));
	......
}

void* ipc_rcu_alloc(int size)
{
	void* out;
	/* 
	 * We prepend the allocation with the rcu struct, and
	 * workqueue if necessary (for vmalloc). 
	 */
	if (rcu_use_vmalloc(size)) {
		out = vmalloc(HDRLEN_VMALLOC + size);
		if (out) {
			out += HDRLEN_VMALLOC;
			container_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 1;
			container_of(out, struct ipc_rcu_hdr, data)->refcount = 1;
		}
	} else {
		out = kmalloc(HDRLEN_KMALLOC + size, GFP_KERNEL);
		if (out) {
			out += HDRLEN_KMALLOC;
			container_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 0;
			container_of(out, struct ipc_rcu_hdr, data)->refcount = 1;
		}
	}

	return out;
}
```
shmid_kernel结构体大小只有80字节大小，但是实际会分配HDRLEN_VMALLOC+80=88大小的内存块，处于kmalloc-96的slab中。我们可以通过解析/proc/slabinfo这个文件来得到相应的slab剩余的object的数目。
```shell
root@w0lfzhang666:/home/w0lfzhang# cat /proc/slabinfo | grep kmalloc-96
kmalloc-96          1269   1288    144   28    1 : tunables    0    0    0 : slabdata     46     46      0 
```
主要关注前面4个字段，分别表示slab_name, active_objs， total_objs， objsize。可通过以下函数得到剩余slab数目：
```c
int check_slabinfo(char *cache, int *active_out, int *total_out)
{
	FILE *fp;
	char name[64], slab[256];
	int active, total, diff;

	memset(slab, 0, sizeof(slab));
	memset(name, 0, sizeof(name));

	fp = fopen("/proc/slabinfo", "r");
	if (!fp) {
		printf("[-] sorry, /proc/slabinfo is not available!");
		exit(1);
	}

	fgets(slab, sizeof(slab) - 1, fp);
	while (1) {
		fgets(slab, sizeof(slab) - 1, fp);
		sscanf(slab, "%s %u %u", name, &active, &total);
		diff = total - active;
		if (strcmp(name, cache) == 0) {
			break;
		}
	}
	fclose(fp);

	if (active_out) {
		*active_out = active;
	}
	if (total_out) {
		*total_out = total;
	}
	return diff;
}
```
首先利用shmget系统调用不断的分配shmid_kernel，直到分配的object是连续的。然后利用slub的FIFO特点，利用shmctl系统调用释放一个shmid_kernel对象，然后触发漏洞代码来分配一个obj。这样可以利用溢出用脏数据覆盖相邻的object。最后只需要利用shmat系统调用来触发mmap函数指针即可。但是其中涉及到许多结构体的字段需要设置才能正常运行exp，还是得去多读一下kernel~具体可参考下面的连接。

本来是用2.6.32.26的内核在做试验，但是slub开启了检测溢出的功能(slub debug)了，覆盖后内核总是panic~
```shell
root@w0lfzhang666:/home/w0lfzhang# cat /sys/kernel/slab/kmalloc-96/red_zone 
1
```
可以关闭debug功能:
```shell
root@w0lfzhang666:/home/w0lfzhang# echo 0 > /sys/kernel/slab/kmalloc-96/red_zone 
```

## Links
[如何诊断SLUB问题](http://www.tuicool.com/articles/ayYn6rr)
[Linux进程间通信（六）：共享内存 shmget()、shmat()、shmdt()、shmctl()](http://www.cnblogs.com/52php/p/5861372.html)
[Linux Kernel CAN SLUB Overflow](https://jon.oberheide.org/blog/2010/09/10/linux-kernel-can-slub-overflow/)
[Linux内核slub溢出攻击技术](http://www.tuicool.com/articles/AVVvMn)
