---
title: 'CVE-2008-0600: vmsplice() Privilege Escalation'
date: 2017-09-24 23:04:44
tags:
- kernel_exploit
- compound pages
- integer overflow
- privilege escalation
categories:
- cve_analysis
---

最近找的漏洞感觉分析起来稍微有点难~所以我干脆决定分析一些比较稍微老点但是比较经典的漏洞......
vmsplice提权漏洞(CVE-2008-0600)的利用姿势还是比较有趣的，所以我就具体分析了下这个漏洞及利用方式。
<!-- more -->

## Env
```
w0lfzhang@w0lfzhang-666:~/Desktop$ uname -a
Linux w0lfzhang-666 2.6.24 #1 SMP Fri Sep 22 22:41:51 CST 2017 i686 GNU/Linux

w0lfzhang@w0lfzhang-666:~/Desktop$ lsb_release -a
No LSB modules are available.
Distributor ID:	Ubuntu
Description:	Ubuntu 8.04.4 LTS
Release:	8.04
Codename:	hardy
```

## Analysis
首先看下CVE-2008-0600的简单描述：
The vmsplice_to_pipe function in Linux kernel 2.6.17 through 2.6.24.1 does not validate a certain userspace pointer before dereference, which allows local users to gain root privileges via crafted arguments in a vmsplice system call, a different vulnerability than CVE-2008-0009 and CVE-2008-0010.

简单的说就是没验证vmsplice函数的指针参数(iov)吧。
```c
ssize_t vmsplice(int fd, const struct iovec *iov,
                        unsigned long nr_segs, unsigned int flags);
```
然后具体分析一下vmsplice系统调用的实现——sys_vmsplice函数。
```c
asmlinkage long sys_vmsplice(int fd, const struct iovec __user *iov,
			     unsigned long nr_segs, unsigned int flags)
{
	struct file *file;
	long error;
	int fput;

	if (unlikely(nr_segs > UIO_MAXIOV))
		return -EINVAL;
	else if (unlikely(!nr_segs))
		return 0;

	error = -EBADF;
	file = fget_light(fd, &fput);
	if (file) {
		if (file->f_mode & FMODE_WRITE)
			error = vmsplice_to_pipe(file, iov, nr_segs, flags);
		else if (file->f_mode & FMODE_READ)
			error = vmsplice_to_user(file, iov, nr_segs, flags);

		fput_light(file, fput);
	}

	return error;
}
```
在FMODE_WRITE分支下是把iov指向的用户缓冲区拷贝到fd(pipe的写端)指向的内核缓冲区，在FMODE_READ分支下把fd(pipe的读端)指向的内核缓冲区拷贝到iov指向的用户缓冲区。漏洞存在vmsplice_to_pipe中，跟进去：
```c
static long vmsplice_to_pipe(struct file *file, const struct iovec __user *iov,
			     unsigned long nr_segs, unsigned int flags)
{
	struct pipe_inode_info *pipe;
	struct page *pages[PIPE_BUFFERS];
	struct partial_page partial[PIPE_BUFFERS];
	struct splice_pipe_desc spd = {
		.pages = pages,
		.partial = partial,
		.flags = flags,
		.ops = &user_page_pipe_buf_ops,
	};

	pipe = pipe_info(file->f_path.dentry->d_inode);
	if (!pipe)
		return -EBADF;

	spd.nr_pages = get_iovec_page_array(iov, nr_segs, pages, partial,
					    flags & SPLICE_F_GIFT);
	if (spd.nr_pages <= 0)
		return spd.nr_pages;

	return splice_to_pipe(pipe, &spd);
}

#define PIPE_BUFFERS (16)
```
现在暂时看不出问题出在哪，跟着iov的传递路径跟进get_iovec_page_array：
```c
static int get_iovec_page_array(const struct iovec __user *iov,
				unsigned int nr_vecs, struct page **pages,
				struct partial_page *partial, int aligned)
{
	int buffers = 0, error = 0;

	down_read(&current->mm->mmap_sem);

	while (nr_vecs) {
		unsigned long off, npages;
		struct iovec entry;
		void __user *base;
		size_t len;
		int i;

		error = -EFAULT;
		if (copy_from_user_mmap_sem(&entry, iov, sizeof(entry)))
			break;

		base = entry.iov_base;
		len = entry.iov_len;

		/*
		 * Sanity check this iovec. 0 read succeeds.
		 */
		error = 0;
		if (unlikely(!len))
			break;
		error = -EFAULT;
		if (unlikely(!base))
			break;

		/*
		 * Get this base offset and number of pages, then map
		 * in the user pages.
		 */
		off = (unsigned long) base & ~PAGE_MASK;

		/*
		 * If asked for alignment, the offset must be zero and the
		 * length a multiple of the PAGE_SIZE.
		 */
		error = -EINVAL;
		if (aligned && (off || len & ~PAGE_MASK))
			break;

		npages = (off + len + PAGE_SIZE - 1) >> PAGE_SHIFT;
		if (npages > PIPE_BUFFERS - buffers)
			npages = PIPE_BUFFERS - buffers;

		error = get_user_pages(current, current->mm,
				       (unsigned long) base, npages, 0, 0,
				       &pages[buffers], NULL);

		if (unlikely(error <= 0))
			break;

		/*
		 * Fill this contiguous range into the partial page map.
		 */
		for (i = 0; i < error; i++) {
			const int plen = min_t(size_t, len, PAGE_SIZE - off);

			partial[buffers].offset = off;
			partial[buffers].len = plen;

			off = 0;
			len -= plen;
			buffers++;
		}

		/*
		 * We didn't complete this iov, stop here since it probably
		 * means we have to move some of this into a pipe to
		 * be able to continue.
		 */
		if (len)
			break;

		/*
		 * Don't continue if we mapped fewer pages than we asked for,
		 * or if we mapped the max number of pages that we have
		 * room for.
		 */
		if (error < npages || buffers == PIPE_BUFFERS)
			break;

		nr_vecs--;
		iov++;
	}

	up_read(&current->mm->mmap_sem);

	if (buffers)
		return buffers;

	return error;
}
```
仔细分析一下下面的代码：
```c
npages = (off + len + PAGE_SIZE - 1) >> PAGE_SHIFT;
```
off是页内偏移(0-4K)，len是用户传进的参数缓冲区的长度(大于0)，PAGE_SIZE为4K，PAGE_SHIFT为12。一般情况下(off + len + PAGE_SIZE - 1)要大于PAGE_SIZE，所以npages也是大于等于1的，但是也是有例外的！因为len是我们可控的(unsigned long)，如果我们传进去的是ULONG_MAX呢？那(off + len + PAGE_SIZE - 1)就溢出了，那就有可能小于PAGE_SIZE，此时npages等于0。然后npages传入get_user_pages：
```c
int get_user_pages(struct task_struct *tsk, struct mm_struct *mm,
		unsigned long start, int len, int write, int force,
		struct page **pages, struct vm_area_struct **vmas)
{
	int i;
	......
	i = 0;

	do {
		......
		i++;
		start += PAGE_SIZE;
		len--;
		continue;
	}

		......

		do {
			struct page *page;

			/*
			 * If tsk is ooming, cut off its access to large memory
			 * allocations. It has a pending SIGKILL, but it can't
			 * be processed until returning to user space.
			 */
			if (unlikely(test_tsk_thread_flag(tsk, TIF_MEMDIE)))
				return -ENOMEM;

			if (write)
				foll_flags |= FOLL_WRITE;

			cond_resched();
			while (!(page = follow_page(vma, start, foll_flags))) {
			......
			i++;
			start += PAGE_SIZE;
			len--;
		} while (len && start < vma->vm_end);
	} while (len);
	return i;
}
```
传进去的npages等于0，也即len等于0，注意此时len是int型的整数。当len减到0xf0000000，然后再减1变成0x7fffffff，然后最终减到0才退出循环。这是返回的i是比较大的(肯定大于16)。然后再回到get_iovec_page_array函数中，get_user_pages的返回值赋给了error，然后紧接着是一个for循环：
```c
for (i = 0; i < error; i++) {
	const int plen = min_t(size_t, len, PAGE_SIZE - off);

	partial[buffers].offset = off;
	partial[buffers].len = plen;

	off = 0;
	len -= plen;
	buffers++;
	}
```
partial数组是从vmsplice_to_pipe传进来的，而partial和分布在pages数组的上面：
```
| partial[] |
| ......... |
| pages[]   |
| .......   |
```
而partial和pages数组大小都是16，所以上面的for循环会把pages数组overwrite，pages数组里面的指针的值要么overwrite为0要么为4096。

分析到现在终于搞清漏洞的细节了：由于get_iovec_page_array未验证用户传入的指针的合法性导致整型溢出，从而在vmsplice_to_pipe里覆盖了pages数组。

## Exploit
这是个LPE漏洞，但是应该怎么提权？vmsplice_to_pipe最后还会执行splice_to_pipe函数：
```c
ssize_t splice_to_pipe(struct pipe_inode_info *pipe,
		       struct splice_pipe_desc *spd)
{
	unsigned int spd_pages = spd->nr_pages;
	int ret, do_wakeup, page_nr;

	ret = 0;
	do_wakeup = 0;
	page_nr = 0;

	if (pipe->inode)
		mutex_lock(&pipe->inode->i_mutex);

	for (;;) {
		if (!pipe->readers) {
			send_sig(SIGPIPE, current, 0);
			if (!ret)
				ret = -EPIPE;
			break;
		}

		......
	}

	while (page_nr < spd_pages)
		page_cache_release(spd->pages[page_nr++]);

	return ret;
}
```
要跳出for循环只要关闭管道的读端就可以，紧接着进入while循环执行page_cache_release函数，spd->pages就是已经覆盖的pages数组：
```c
#define page_cache_release(page)	put_page(page)

void put_page(struct page *page)
{
	if (unlikely(PageCompound(page)))
		put_compound_page(page);
	else if (put_page_testzero(page))
		__page_cache_release(page);
}
```
只要page指向的内存页是[复合页](https://lwn.net/Articles/619514/)，那就会执行put_compound_page函数:
```c
static void put_compound_page(struct page *page)
{
	page = compound_head(page);
	if (put_page_testzero(page)) {
		compound_page_dtor *dtor;

		dtor = get_compound_page_dtor(page);
		(*dtor)(page);
	}
}

static inline compound_page_dtor *get_compound_page_dtor(struct page *page)
{
	return (compound_page_dtor *)page[1].lru.next;
}
```
所以内核最终会执行page[1]里面的lru字段的next函数指针。由于pages数组里的指针已经被覆盖为0或者4096了，所以我们可以在用户空间mmap(0), mmap(4096)，然后我们可以控制page[1]的相关字段，把next字段覆盖为提权函数，game over！
```shell
w0lfzhang@w0lfzhang-666:~/Desktop$ ./pwn2
-----------------------------------
 Linux vmsplice Local Root Exploit
 By qaaz
-----------------------------------
[+] mmap: 0x0 .. 0x1000
[+] page: 0x0
[+] page: 0x20
[+] mmap: 0x1000 .. 0x2000
[+] page: 0x1000
[+] mmap: 0xb7df6000 .. 0xb7e28000
[+] root
# id
uid=0(root) gid=0(root) groups=4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),107(fuse),109(lpadmin),115(admin),124(sambashare),1000(w0lfzhang)
```

## Patch
```c
diff --git a/fs/splice.c b/fs/splice.c
index 14e2262..9b559ee 100644
--- a/fs/splice.c
+++ b/fs/splice.c
@@ -1234,7 +1234,7 @@ static int get_iovec_page_array(const struct iovec __user *iov,
 		if (unlikely(!len))
 			break;
 		error = -EFAULT;
-		if (unlikely(!base))
+		if (!access_ok(VERIFY_READ, base, len))
 			break;
 
 		/*
```
patch也很简单，检测base~base+len内存区域是否为有效的用户空间地址即可。

最后只想说，看内核源码真累！
## Links
[Linux Kernel 2.6.17 < 2.6.24.1 - 'vmsplice' Privilege Escalation (2)](https://www.exploit-db.com/exploits/5092/)
[linux使普通用户获得root权限的vmsplice系统调用漏洞分析](http://blog.delai.me/blog/2008/12/29/linux-vmsplice/)
[vmsplice(): the making of a local root exploit](https://lwn.net/Articles/268783/)

