---
title: 'CVE-2009-2692: How to Bypass mmap_min_addr'
date: 2017-09-26 15:19:30
tags:
- bypass mmap_min_addr
- privilege escalation
categories:
- cve_analysis
---

首先看一下这个漏洞的简要描述：
The Linux kernel 2.6.0 through 2.6.30.4, and 2.4.4 through 2.4.37.4, does not initialize all function pointers for socket operations in proto_ops structures, which allows local users to trigger a NULL pointer dereference and gain privileges by using mmap to map page zero, placing arbitrary code on this page, and then invoking an unavailable operation, as demonstrated by the sendpage operation (sock_sendpage function) on a PF_PPPOX socket.
<!-- more -->
说来也很简单，就是由于socket结构体的proto_ops字段里的有些函数指针没有初始化可以导致NULL pointer dereference。虽然这种漏洞提权很简单，但是前提是可以mmap page zero！但是linux大部分情况下是设置mmap_min_addr大于等于65536的，所以在实际漏洞利用中我们一般是无法mmap page zero的，除非绕过这个限制！这就是我为什么要花点时间研究一下这个漏洞的原因——因为exp中介绍了一种可以bypass NULL pointer dereference防御的方法！

## cve-2009-2692 analysis
首先还是简单分析一下这个漏洞的成因。前面的描述居然不说漏洞在哪个函数~害得我找了老半天没找着，最后还是在另外一个地方找到了稍微详细点的描述：
Description of problem:
Reported by Tavis Ormandy and Julien Tinnes. The SOCKOPS_WRAP macro from include/linux/net.h doesn't initialise the sendpage operation in the proto_ops structure correctly. Leading to a kernel NULL pointer dereference, and thus a local privilege escalation.
看下SOCKOPS_WRAP到底是怎么初始化proto_ops的：
```c
#define SOCKOPS_WRAP(name, fam)					\
SOCKCALL_WRAP(name, release, (struct socket *sock), (sock))	\
SOCKCALL_WRAP(name, bind, (struct socket *sock, struct sockaddr *uaddr, int addr_len), \
	      (sock, uaddr, addr_len))				\
SOCKCALL_WRAP(name, connect, (struct socket *sock, struct sockaddr * uaddr, \
			      int addr_len, int flags), 	\
	      (sock, uaddr, addr_len, flags))			\
SOCKCALL_WRAP(name, socketpair, (struct socket *sock1, struct socket *sock2), \
	      (sock1, sock2))					\
SOCKCALL_WRAP(name, accept, (struct socket *sock, struct socket *newsock, \
			 int flags), (sock, newsock, flags)) \
SOCKCALL_WRAP(name, getname, (struct socket *sock, struct sockaddr *uaddr, \
			 int *addr_len, int peer), (sock, uaddr, addr_len, peer)) \
SOCKCALL_UWRAP(name, poll, (struct file *file, struct socket *sock, struct poll_table_struct *wait), \
	      (file, sock, wait)) \
SOCKCALL_WRAP(name, ioctl, (struct socket *sock, unsigned int cmd, \
			 unsigned long arg), (sock, cmd, arg)) \
SOCKCALL_WRAP(name, compat_ioctl, (struct socket *sock, unsigned int cmd, \
			 unsigned long arg), (sock, cmd, arg)) \
SOCKCALL_WRAP(name, listen, (struct socket *sock, int len), (sock, len)) \
SOCKCALL_WRAP(name, shutdown, (struct socket *sock, int flags), (sock, flags)) \
SOCKCALL_WRAP(name, setsockopt, (struct socket *sock, int level, int optname, \
			 char __user *optval, int optlen), (sock, level, optname, optval, optlen)) \
SOCKCALL_WRAP(name, getsockopt, (struct socket *sock, int level, int optname, \
			 char __user *optval, int __user *optlen), (sock, level, optname, optval, optlen)) \
SOCKCALL_WRAP(name, sendmsg, (struct kiocb *iocb, struct socket *sock, struct msghdr *m, size_t len), \
	      (iocb, sock, m, len)) \
SOCKCALL_WRAP(name, recvmsg, (struct kiocb *iocb, struct socket *sock, struct msghdr *m, size_t len, int flags), \
	      (iocb, sock, m, len, flags)) \
SOCKCALL_WRAP(name, mmap, (struct file *file, struct socket *sock, struct vm_area_struct *vma), \
	      (file, sock, vma)) \
	      \
static const struct proto_ops name##_ops = {			\
	.family		= fam,				\
	.owner		= THIS_MODULE,			\
	.release	= __lock_##name##_release,	\
	.bind		= __lock_##name##_bind,		\
	.connect	= __lock_##name##_connect,	\
	.socketpair	= __lock_##name##_socketpair,	\
	.accept		= __lock_##name##_accept,	\
	.getname	= __lock_##name##_getname,	\
	.poll		= __lock_##name##_poll,		\
	.ioctl		= __lock_##name##_ioctl,	\
	.compat_ioctl	= __lock_##name##_compat_ioctl,	\
	.listen		= __lock_##name##_listen,	\
	.shutdown	= __lock_##name##_shutdown,	\
	.setsockopt	= __lock_##name##_setsockopt,	\
	.getsockopt	= __lock_##name##_getsockopt,	\
	.sendmsg	= __lock_##name##_sendmsg,	\
	.recvmsg	= __lock_##name##_recvmsg,	\
	.mmap		= __lock_##name##_mmap,		\
};
```
proto_ops最后一个函数指针sendpage没有初始化，从而在调用sock_sendpage是会导致NULL pointer dereference。受影响的protocol有很多，不只是上面提到的PF_PPPOX。可以这样看哪些protocol受到了影响：
```c
repeat_it:
		for (; domains[d][0] != DOMAINS_STOP; d++) {
			if ((out = socket(domains[d][0], domains[d][1], domains[d][2])) >= 0)
				break;
		}
    
		if (out < 0) {
			fprintf(stdout, "unable to find a vulnerable domain, sorry\n");
			return 1;
		}

		// Truncate input file to some large value
		ftruncate(in, getpagesize());

		// sendfile() to trigger the bug.
		sendfile(out, in, NULL, getpagesize());
	}

	if (got_ring0) {
		printf("target domain: %d\n", d);
		fprintf(stdout, " [+] got ring0!\n");
	} else {
		d++;
		goto repeat_it;
	}
```
具体exp请参考[这里](https://github.com/SecWiki/linux-kernel-exploits/tree/master/2009/CVE-2009-2692)。

## Bypass mmap_min_addr protection
现在关键是怎么bypass mmap_min_addr protection。
这就需要利用到另外一个漏洞——CVE-2009-1895。看下这个漏洞的描述：
The personality subsystem in the Linux kernel before 2.6.31-rc3 has a PER_CLEAR_ON_SETID setting that does not clear the ADDR_COMPAT_LAYOUT and MMAP_PAGE_ZERO flags when executing a setuid or setgid program, which makes it easier for local users to leverage the details of memory usage to (1) conduct NULL pointer dereference attacks, (2) bypass the mmap_min_addr protection mechanism, or (3) defeat address space layout randomization (ASLR).
分析一下源码：
```c
/*
 * Flags for bug emulation.
 *
 * These occupy the top three bytes.
 */
enum {
       ADDR_NO_RANDOMIZE =     0x0040000,      /* disable randomization of VA space */
       FDPIC_FUNCPTRS =        0x0080000,      /* userspace function ptrs point to descriptors
                                                * (signal handling)
                                                */
       MMAP_PAGE_ZERO =        0x0100000,
       ADDR_COMPAT_LAYOUT =    0x0200000,
       READ_IMPLIES_EXEC =     0x0400000,
       ADDR_LIMIT_32BIT =      0x0800000,
       SHORT_INODE =           0x1000000,
       WHOLE_SECONDS =         0x2000000,
       STICKY_TIMEOUTS =       0x4000000,
       ADDR_LIMIT_3GB =        0x8000000,
};
 
/*
 * Security-relevant compatibility flags that must be
 * cleared upon setuid or setgid exec:
 */
#define PER_CLEAR_ON_SETID (READ_IMPLIES_EXEC|ADDR_NO_RANDOMIZE)
```
所以我们只需要找到一个setuid的program可以执行我们的exp就能绕过mmap_min_addr protection。
首先用personality系统调用设置persona：
```c
ret = personality(PER_SVR4);

//PER_SVR4 = 0x0001 | STICKY_TIMEOUTS | MMAP_PAGE_ZERO
//PER_SVR4 = 0x4100001
```
然后suid program会clear PER_CLEAR_ON_SETID，但是MMAP_PAGE_ZERO并没有clear，所以程序此时可以mmap page zero。然后就是布置payload即可。
很辛运的是在大部分linux中都有这样一个setuid的program：pulseaudio，而且可以通过他的-L选项来执行我们的exp。
```c
execl(PULSEAUDIO_PATH, PULSEAUDIO_PATH, "--log-level=0", "-L", PATH_TO_EXPLOIT, NULL);
```
现在的话这个漏洞基本已经被修复了。
```c
#define PER_CLEAR_ON_SETID (READ_IMPLIES_EXEC|ADDR_NO_RANDOMIZE|ADDR_COMPAT_LAYOUT|MMAP_PAGE_ZERO)
```

所以现在还有什么措施能绕过NULL pointer dereference protection？

## Patch
```shell
diff --git a/net/socket.c b/net/socket.c
index 791d71a..6d47165 100644
--- a/net/socket.c
+++ b/net/socket.c
@@ -736,7 +736,7 @@ static ssize_t sock_sendpage(struct file *file, struct page *page,
 	if (more)
 		flags |= MSG_MORE;
 
-	return sock->ops->sendpage(sock, page, offset, size, flags);
+	return kernel_sendpage(sock, page, offset, size, flags);
 }
```

## Links
[Bug 516949 - (CVE-2009-2692) CVE-2009-2692 kernel: uninit op in SOCKOPS_WRAP() leads to privesc](https://bugzilla.redhat.com/show_bug.cgi?id=516949)
[Bypassing Linux' NULL pointer dereference exploit prevention (mmap_min_addr)](http://webcache.googleusercontent.com/search?q=cache:http://blog.cr0.org/2009/06/bypassing-linux-null-pointer.html)
[CVE-2009-1895: Linux kernel PER_CLEAR_ON_SETID Personality Bypass](https://xorl.wordpress.com/2009/07/16/cve-2009-1895-linux-kernel-per_clear_on_setid-personality-bypass/)
[CVE-2009-1895](https://access.redhat.com/security/cve/cve-2009-1895)
[PERSONALITY(2) ](http://man7.org/linux/man-pages/man2/personality.2.html)