---
title: 2015 CSAW CTF Kernel Exploit
date: 2017-08-27 13:58:44
tags:
- kernel arbitray write/read
- overwrite cred
categories:
- kernel_exploit_practice
---

## Challenge
花了点时间看了[源码](https://github.com/mncoppola/StringIPC/blob/master/main.c)，逻辑比较简单。
内核模块实现了一个简单的IPC通信系统，进程可对分配的特定内存区域进行read/write/seek等操作来进行通信。
每次最难的地方就是找洞~不过也是有一定规律，大部分情况下可以通过跟踪输入查看程序执行流来发现漏洞。
<!-- more -->
所以仔细审查核心函数csaw_ioctl：
```c
static long csaw_ioctl ( struct file *file, unsigned int cmd, unsigned long arg )
{
    long ret = 0;
    unsigned long *argp = (unsigned long *)arg;
    struct ipc_state *state = file->private_data;

    switch ( cmd )
    {
        case CSAW_ALLOC_CHANNEL:
        {
            struct alloc_channel_args alloc_channel;
            struct ipc_channel *channel;

            if ( copy_from_user(&alloc_channel, argp, sizeof(alloc_channel)) )
                return -EINVAL;

            mutex_lock(&state->lock);

            if ( state->channel )
            {
                ret = -EBUSY;
                goto RET_UNLOCK;
            }

            ret = alloc_new_ipc_channel(alloc_channel.buf_size, &channel);
            if ( ret < 0 )
                goto RET_UNLOCK;

            state->channel = channel;

            if ( ret < 0 )
                alloc_channel.id = 0;
            else
                alloc_channel.id = channel->id;

            if ( copy_to_user(argp, &alloc_channel, sizeof(alloc_channel)) )
            {
                close_ipc_channel(state, channel->id);
                ret = -EINVAL;
            }

            mutex_unlock(&state->lock);

            break;
        }

        case CSAW_OPEN_CHANNEL:
        {
            struct open_channel_args open_channel;
            struct ipc_channel *channel;

            if ( copy_from_user(&open_channel, argp, sizeof(open_channel)) )
                return -EINVAL;

            mutex_lock(&state->lock);

            if ( state->channel )
            {
                ret = -EBUSY;
                goto RET_UNLOCK;
            }

            channel = get_channel_by_id(state, open_channel.id);
            if ( IS_ERR(channel) )
            {
                ret = PTR_ERR(channel);
                goto RET_UNLOCK;
            }

            state->channel = channel;

            ipc_channel_put(state, channel);

            mutex_unlock(&state->lock);

            break;
        }

        case CSAW_GROW_CHANNEL:
        {
            struct grow_channel_args grow_channel;

            if ( copy_from_user(&grow_channel, argp, sizeof(grow_channel)) )
                return -EINVAL;

            mutex_lock(&state->lock);
            ret = realloc_ipc_channel(state, grow_channel.id, grow_channel.size, 1);
            mutex_unlock(&state->lock);

            break;
        }

        case CSAW_SHRINK_CHANNEL:
        {
            struct shrink_channel_args shrink_channel;

            if ( copy_from_user(&shrink_channel, argp, sizeof(shrink_channel)) )
                return -EINVAL;

            mutex_lock(&state->lock);
            ret = realloc_ipc_channel(state, shrink_channel.id, shrink_channel.size, 0);
            mutex_unlock(&state->lock);

            break;
        }

        case CSAW_READ_CHANNEL:
        {
            struct read_channel_args read_channel;

            if ( copy_from_user(&read_channel, argp, sizeof(read_channel)) )
                return -EINVAL;

            mutex_lock(&state->lock);
            ret = read_ipc_channel(state, read_channel.buf, read_channel.count);
            mutex_unlock(&state->lock);

            break;
        }

        case CSAW_WRITE_CHANNEL:
        {
            struct write_channel_args write_channel;

            if ( copy_from_user(&write_channel, argp, sizeof(write_channel)) )
                return -EINVAL;

            mutex_lock(&state->lock);
            ret = write_ipc_channel(state, write_channel.buf, write_channel.count);
            mutex_unlock(&state->lock);

            break;
        }

        case CSAW_SEEK_CHANNEL:
        {
            struct seek_channel_args seek_channel;

            if ( copy_from_user(&seek_channel, argp, sizeof(seek_channel)) )
                return -EINVAL;

            mutex_lock(&state->lock);
            ret = seek_ipc_channel(state, seek_channel.index, seek_channel.whence);
            mutex_unlock(&state->lock);

            break;
        }

        case CSAW_CLOSE_CHANNEL:
        {
            struct close_channel_args close_channel;

            if ( copy_from_user(&close_channel, argp, sizeof(close_channel)) )
                return -EINVAL;

            mutex_lock(&state->lock);
            ret = close_ipc_channel(state, close_channel.id);
            mutex_unlock(&state->lock);

            break;
        }
    }

    return ret;

RET_UNLOCK:
    mutex_unlock(&state->lock);
    return ret;
}
```
然而我并没有找出啥漏洞~，(真的是渣~)看了wp才知道问题出在哪。问题出在krealloc函数，也就是说realloc_ipc_channel这个函数有问题：
```c
static int realloc_ipc_channel ( struct ipc_state *state, int id, size_t size, int grow )
{
    struct ipc_channel *channel;
    size_t new_size;
    char *new_data;

    channel = get_channel_by_id(state, id);
    if ( IS_ERR(channel) )
        return PTR_ERR(channel);

    if ( grow )
        new_size = channel->buf_size + size;
    else
        new_size = channel->buf_size - size;

    new_data = krealloc(channel->data, new_size + 1, GFP_KERNEL); <== bug here
    if ( new_data == NULL )
        return -EINVAL;

    channel->data = new_data;
    channel->buf_size = new_size;

    ipc_channel_put(state, channel);

    return 0;
}
```
我们看一下krealloc的源码：
```c
void *krealloc(const void *p, size_t new_size, gfp_t flags)
{
    void *ret;

    if (unlikely(!new_size)) {  <== attention here!
        kfree(p);
        return ZERO_SIZE_PTR;
    }   

    ret = __do_krealloc(p, new_size, flags);
    if (ret && p != ret)
        kfree(p);

    return ret;
}

#define ZERO_SIZE_PTR ((void *)16)
```
如果new_size为0的话，krealloc就会返回ZERO_SIZE_PTR，虽然值为16，但是kfree函数会正确的处理这种情况。所以在本题中只需要把new_size设置为0xffffffffffffffff即可，这样channel->data = 16, channel->buf_size = 0xffffffffffffffff，所以在read_ipc_channel和write_ipc_channel函数中以下条件就可以轻松的绕过从而结合seek_ipc_channel函数达到任意读和写的目的。
```c
static ssize_t read_ipc_channel ( struct ipc_state *state, char __user *buf, size_t count )
{
	......
    if ( (count + *pos) > channel->buf_size )
        return -EINVAL;

    if ( copy_to_user(buf, channel->data + *pos, count) )
        return -EINVAL;

    return count;
}

static ssize_t write_ipc_channel ( struct ipc_state *state, const char __user *buf, size_t count )
{
	......
    if ( (count + *pos) > channel->buf_size )
        return -EINVAL;

    if ( strncpy_from_user(channel->data + *pos, buf, count) < 0 )
        return -EINVAL;

    return count;
}
````
## Exploit
这个challenge内核开启了SMEP，kptr_restrict和dmesg_restrict都被设置为1，这意味着我们再内核态无法执行用户空间的代码，无法读取/proc/kallsyms中的导出函数的地址，无法读取dmesg命令中泄露的内核地址。
好吧，我又学到了一个套路，直接overwrite进程的cred！这样上面的保护措施全部都绕过了，美滋滋。另一个套路overwirte vdso没怎么看懂，还得去google一下~
我们首先得找到进程的cred的地址，这就需要用到task_struct中的comm字段了。
```c
struct task_struct {
	......
	/* process credentials */
	const struct cred __rcu *real_cred; /* objective and real subjective task
					 * credentials (COW) */
	const struct cred __rcu *cred;	/* effective (overridable) subjective task
					 * credentials (COW) */
	char comm[TASK_COMM_LEN]; /* executable name excluding path
				     - access with [gs]et_task_comm (which lock
				       it with task_lock())
				     - initialized normally by setup_new_exec */
	......
}
```
我们可以在用户态用[prctl函数](http://man7.org/linux/man-pages/man2/prctl.2.html)来设置comm数组的值，然后在内核中搜寻这个字符串(准确的说应该是字符数组)并且确保他前面的两个qwords是一个有效的内核指针。找到cred的地址后，然后只需要把cred结构体中的uid/gid设置为0即可。
```c
struct cred {
	atomic_t	usage;
#ifdef CONFIG_DEBUG_CREDENTIALS
	atomic_t	subscribers;	/* number of processes subscribed */
	void		*put_addr;
	unsigned	magic;
#define CRED_MAGIC	0x43736564
#define CRED_MAGIC_DEAD	0x44656144
#endif
	kuid_t		uid;		/* real UID of the task */
	kgid_t		gid;		/* real GID of the task */
	kuid_t		suid;		/* saved UID of the task */
	kgid_t		sgid;		/* saved GID of the task */
	kuid_t		euid;		/* effective UID of the task */
	kgid_t		egid;		/* effective GID of the task */
	kuid_t		fsuid;		/* UID for VFS ops */
	kgid_t		fsgid;		/* GID for VFS ops */
	......
};
```
跳过usage字段，把下面8个字段设置为0(uid-fsgid)。这个操作在内核漏洞利用的防范中提到过，由于那时比较'懵懂无知'，所以没怎么仔细看。
需要注意的是我们需要把real_cred和cred里面的相关id都设置为0，以前我一直以为只要设置cred字段即可。我们可以看一下commit_creds函数的源码：
```c
/**
 * commit_creds - Install new credentials upon the current task
 * @new: The credentials to be assigned
 *
 * Install a new set of credentials to the current task, using RCU to replace
 * the old set.  Both the objective and the subjective credentials pointers are
 * updated.  This function may not be called if the subjective credentials are
 * in an overridden state.
 *
 * This function eats the caller's reference to the new credentials.
 *
 * Always returns 0 thus allowing this function to be tail-called at the end
 * of, say, sys_setgid().
 */
int commit_creds(struct cred *new)
{
    struct task_struct *task = current;
    const struct cred *old = task->real_cred;
    ......

    /* do it
     * RLIMIT_NPROC limits on user->processes have already been checked
     * in set_user().
     */
    alter_cred_subscribers(new, 2);
    if (new->user != old->user)
        atomic_inc(&new->user->processes);
    rcu_assign_pointer(task->real_cred, new);  <==
    rcu_assign_pointer(task->cred, new);       <==
    if (new->user != old->user)
        atomic_dec(&old->user->processes);
    alter_cred_subscribers(old, -2);
    ......
    return 0;
}
```
所以提权时的代码如下：
```c
escalate_creds(fd, id, real_cred);

if ( cred != real_cred )
    escalate_creds(fd, id, cred);
```
详细exp可在这里[下载](https://github.com/mncoppola/StringIPC/blob/master/solution/solution.c)到。

## Links
[CSAW CTF 2015 Kernel Exploitation Challenge](https://poppopret.org/2015/11/16/csaw-ctf-2015-kernel-exploitation-challenge/)

