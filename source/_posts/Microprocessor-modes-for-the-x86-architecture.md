---
title: Microprocessor modes for the x86 architecture
date: 2018-11-08 15:56:18
tags:
- CPU mode
- page table
categories:
- KVM
---

There are several microprocessor modes fot the x86 architecture. And I gonna have a detail learning about them:
**1. Real mode**
**2. Protected mode**
**3. Virtual 8086 mode**
**4. System Management Mode**
**5. Long mode**
We'll discuss them one by one and how to switch the mode among them. Also, there is an other mode called unreal mode, which we don't talk about. It's not difficult to understand what we gonna talk about for those guys who leraned *Principles of Micro-computer*.
<!--more-->

## Modes Introduction
### Real Mode
Real mode is an operating mode of all x86-compatible CPUs. In this mode, address bus's width is 20 and the data bus's width is 16. The program has unlimited direct software access to all addressable memory, I/O addresses and peripheral hardware. Real mode provides no support for memory protection, multitasking, or code privilege levels. It has the following features:
**MAX 1M physical memory access**
**All registers 16 bits width**
**The default CPU operand length is only 16 bits**
**Addressing by form of segment:offset**
**No paging, no virtual address, only physical address**
**PhysicalAddress = Segment * 16 + Offset**

### Protected Mode
Let's first figure out what logical address and linear address are.
Address generated by CPU while a program is running is referred as Logical Address, which is also called Virtual Address and consists of /*selector*/ and /*offset*/, selector:offset. The logical address is a virtual address and can be viewed by the user directly. The logical address is used like a reference, to access the physical address.
The linear address is created via adding logical address to the base of segment, 
CS, DS, ES, SS, FS or GS, which means it's handled by the segment selector. If paging is enabled, the linear address must be translated to physical address with the page table. If paging is not enabled, the linear address is the physical address.
In protected mode, the memory management contains [segmentation unit and paging unit](https://www.cs.columbia.edu/~junfeng/12sp-w4118/lectures/l05-mem.pdf). The logical address is translated to linear address via segmentation unit and then the linear address is invisibly translated to physical address.
The features protected mode has:
**32 bit width data and address bus**
**most registers are 32 bit width except the segment registers**
**Protected physical memory**
**Segmentation And Paging addressing**
**Multitasking**
**four privilege levels: ring0-ring3**

### Virtual 8086 Mode
In the 80386 microprocessor and later, virtual 8086 mode (also called virtual real mode, V86-mode or VM86) allows the execution of real mode applications that are incapable of running directly in protected mode while the processor is running a protected mode operating system. Actually, it's just a feature of protected mode, not a **real mode**.

### System Management Mode
The system management mode is a special-purpose operating mode provided for handling system-wide functions like power management, system hardware control, or proprietary OEM designed code. It is intended for use only by system firmware, not by applications software or general-purpose systems software. The main benefit of SMM is that it offers a distinct and easily isolated processor environment that operates transparently to the operating system or executive and software applications.

### Long Mode
In the x86-64 computer architecture, long mode is the mode where a 64-bit operating system can access 64-bit instructions and registers. 64-bit programs are run in a sub-mode called 64-bit mode, while 32-bit programs and 16-bit protected mode programs are executed in a sub-mode called compatibility mode. Real mode or virtual 8086 mode programs cannot be natively run in long mode.
64-bit mode provides a lot of new features, 64-bit registers, eight new general-purpose registers(r8-r15) and so on. 
Not all 64-bit processors can use the long mode, you can use CPUID instruction to detect the presence of long mode.

## Modes Switching
The Control Registers could change or control the CPU's behaviour. Common tasks performed by control registers include interrupt control, switching the addressing mode, paging control, and coprocessor control. Normally, there are 8 control registers in x86 series, while in x86_64 series, three addtional control registers are added: EFER, CR8 and XCR0.
More details about control registers, you can view [this page](https://en.wikipedia.org/wiki/Control_register).

### Entering protected mode
Entering the protected mode from real mode, we just enable CR0's bit 0, which is also called PE. And more about paging, see the part 2 of chapter 5, *AMD64 Architecture Programmer's Manual, Volume 2*.
```asm
; set PE bit
cli            ; disable interrupts
lgdt [gdtr]    ; load GDT register with start address of Global Descriptor Table
mov eax, cr0 
or al, 1       ; set PE (Protection Enable) bit in CR0 (Control Register 0)
mov cr0, eax
 
; Perform far jump to selector 08h (offset into GDT, pointing at a 32bit PM code segment descriptor) 
; to load CS with proper PM32 descriptor)
jmp 08h:PModeMain
 
PModeMain:
; load DS, ES, FS, GS, SS, ESP
```
### Entering V86 mode
The CPU is executing in virtual 86 mode when the VM bit (bit 17) is set in the EFLAGS register.
```asm
; you should declare this function as :
; extern void entering_v86(uint32_t ss, uint32_t esp, uint32_t cs, uint32_t eip);
entering_v86:
   mov epb, esp               ; save stack pointer

   push dword  [ebp+4]        ; ss
   push dword  [ebp+8]        ; esp
   pushfd                     ; eflags
   or dword [esp], (1 << 17)  ; set VM flags
   push dword [ebp+12]        ; cs
   push dword  [ebp+16]       ; eip
   iret
```
### Entering long mode
Then we talk about how to entering long mode. The most complicated part is to set up the paging. 
Before activating long mode, [PAE(Physical Address Extension)](https://en.wikipedia.org/wiki/Physical_Address_Extension) must be enabled by setting CR4.PAE to 1. On 32-bit OS, enabling PAE makes it possible to access more than 4GB RAM, which translates the 32-bit virtual address to 36-bit physical address. While on x86_64 archs, enabling PAE supports mapping of 64-bit virtual address into 52-bit physical address. With PAE paging in long mode, we have page-directory pointer table(PDPT), the page-directory talbe(PDT), the page table(PT) and another new table that is page-map level-4 table(PML4T). The following is a 4-KB page translation in long mode.
<img src="/images/4-kb-paging.png" width="600" height="300">
First we should disable the old paging first (you can skip this if you never set up paging in protected mode) as this is required.
```asm
 mov eax, cr0                                   ; Set the A-register to control register 0.
 and eax, 01111111111111111111111111111111b     ; Clear the PG-bit, which is bit 31.
 mov cr0, eax
```
In long mode, the CR3 register is used to point to the PML4 base address(physical address). First clearing the tables:
```asm
mov edi, 0x1000    ; Set the destination index to 0x1000.
mov cr3, edi       ; Set control register 3 to the destination index.
xor eax, eax       ; Nullify the A-register.
mov ecx, 4096      ; Set the count to 4096.
rep stosd          ; Clear the memory.
mov edi, cr3       ; Set the destination index to control register 3.
```
It's clear PML4T is located at 0x1000, and we gonna make PDPT located at 0x2000, PDT at 0x3000 and PT at 0x400.
```asm
mov DWORD [edi], 0x2003      ; Set the uint32_t at the destination index to 0x2003.
add edi, 0x1000              ; Add 0x1000 to the destination index.
mov DWORD [edi], 0x3003      ; Set the uint32_t at the destination index to 0x3003.
add edi, 0x1000              ; Add 0x1000 to the destination index.
mov DWORD [edi], 0x4003      ; Set the uint32_t at the destination index to 0x4003.
add edi, 0x1000
```
Notice that the first 2 bits is set, which indicates the page is present and it's readable and writeable. Then we gonna map the first 2M memory:
```asm
    mov ebx, 0x00000003          ; Set the B-register to 0x00000003.
    mov ecx, 512                 ; Set the C-register to 512.
 
.SetEntry:
    mov DWORD [edi], ebx         ; Set the uint32_t at the destination index to the B-register.
    add ebx, 0x1000              ; Add 0x1000 to the B-register.
    add edi, 8                   ; Add eight to the destination index.
    loop .SetEntry               ; Set the next entry.
```
We've finished setting up the page table. Next is to enable PAE-paging by setting CR4.PAE:
```asm
mov eax, cr4                 ; Set the A-register to control register 4.
or eax, 1 << 5               ; Set the PAE-bit, which is the 6th bit (bit 5).
mov cr4, eax
```
And you can enter long mode from real mode or protected mode.
Switching from real mode:
```asm
    mov ecx, 0xC0000080          ; Set the C-register to 0xC0000080, which is the EFER MSR.
    rdmsr                        ; Read from the model-specific register.
    or eax, 1 << 8               ; Set the LM-bit which is the 9th bit (bit 8).
    wrmsr 

    ; enabling paging and protected mode.
    mov eax, cr0                 ; Set the A-register to control register 0.
    or eax, 1 << 31 | 1 << 0     ; Set the PG-bit, which is the 31nd bit, and the PM-bit, which is the 0th bit.
    mov cr0, eax 
```
Switching from protected mode:
```asm
    mov ecx, 0xC0000080          ; Set the C-register to 0xC0000080, which is the EFER MSR.
    rdmsr                        ; Read from the model-specific register.
    or eax, 1 << 8               ; Set the LM-bit which is the 9th bit (bit 8).
    wrmsr

    ; enabling paging
    mov eax, cr0                 ; Set the A-register to control register 0.
    or eax, 1 << 31              ; Set the PG-bit, which is the 32nd bit (bit 31).
    mov cr0, eax
```
More about model-specific register (MSR), see [here](http://www.sandpile.org/x86/msr.htm).
After these operations, we're in compatibility mode. The last thing we should do is to load a GDT like this:
```asm
GDT64:                           ; Global Descriptor Table (64-bit).
    .Null: equ $ - GDT64         ; The null descriptor.
    dw 0xFFFF                    ; Limit (low).
    dw 0                         ; Base (low).
    db 0                         ; Base (middle)
    db 0                         ; Access.
    db 1                         ; Granularity.
    db 0                         ; Base (high).
    .Code: equ $ - GDT64         ; The code descriptor.
    dw 0                         ; Limit (low).
    dw 0                         ; Base (low).
    db 0                         ; Base (middle)
    db 10011010b                 ; Access (exec/read).
    db 10101111b                 ; Granularity, 64 bits flag, limit19:16.
    db 0                         ; Base (high).
    .Data: equ $ - GDT64         ; The data descriptor.
    dw 0                         ; Limit (low).
    dw 0                         ; Base (low).
    db 0                         ; Base (middle)
    db 10010010b                 ; Access (read/write).
    db 00000000b                 ; Granularity.
    db 0                         ; Base (high).
    .Pointer:                    ; The GDT-pointer.
    dw $ - GDT64 - 1             ; Limit.
    dq GDT64                     ; Base.
```
Last we jump to the 64-bit world:
```asm
lgdt [GDT64.Pointer]         ; Load the 64-bit global descriptor table.
jmp GDT64.Code:Realm64       ; Set the code segment and enter 64-bit long mode
```
You can do what you want to do now:
```asm
; Use 64-bit.
[BITS 64]
 
Realm64:
    cli                           ; Clear the interrupt flag, not setting IDT.
    mov ax, GDT64.Data            ; Set the A-register to the data descriptor.
    mov ds, ax                    ; Set the data segment to the A-register.
    mov es, ax                    ; Set the extra segment to the A-register.
    mov fs, ax                    ; Set the F-segment to the A-register.
    mov gs, ax                    ; Set the G-segment to the A-register.
    mov ss, ax                    ; Set the stack segment to the A-register.
    mov edi, 0xB8000              ; Set the destination index to 0xB8000.
    mov rax, 0x1F201F201F201F20   ; Set the A-register to 0x1F201F201F201F20.
    mov ecx, 500                  ; Set the C-register to 500.
    rep stosq                     ; Clear the screen.
    hlt                           ; Halt the processor.
```
## References
[实模式和保护模式区别及寻址方式](https://blog.csdn.net/rosetta/article/details/8933200)
[实模式和保护模式](https://blog.csdn.net/laviolette/article/details/51658650)
[System Management Mode](https://en.wikipedia.org/wiki/System_Management_Mode)
[Protected Mode](https://wiki.osdev.org/Protected_Mode)
[Virtual 8086 Mode](https://wiki.osdev.org/Virtual_8086_Mode)
[Setting Up Long Mode](https://wiki.osdev.org/Setting_Up_Long_Mode)