---
title: 2014 CSAW CTF Kernel Exploit
date: 2017-08-26 13:06:37
tags:
- kernel UAF
- rootkit
categories:
- kernel_exploit_practice
---

这个题我看了半天，可能眼睛近视了~审计源代码一定得细心细心再细心，不然你看啥都觉得没问题~

## Challenge
[源码](https://github.com/mncoppola/suckerusu/blob/master/main.c)不长，而且很有学习意义，跟上一篇的rootkit有关，很值得阅读阅读。
<!-- more -->
这个内核模块实现了隐藏文件和进程的功能，然后hooking了系统调用shmctl，让我们可以通过shmctl系统调用来隐藏文件和进程以及解除隐藏状态。核心函数hook_sys_shmctl如下：
```c
int hook_sys_shmctl ( int shmid, int cmd, struct shmid_ds *buf )
{
    /* This is the good stuff */
    if ( shmid == AUTH_TOKEN )
    {
        int ret = 0;

        DEBUG("Authenticated!\n");

        switch ( cmd )
        {
            /* Elevate privileges to root */
            case 0:
            {
                // TODO
                break;
            }

            /* Hide process */
            case 1:
            {
                struct pid_args pid_args;

                DEBUG("Hiding process\n");

                if ( copy_from_user(&pid_args, buf, sizeof(pid_args)) )
                    return -EFAULT;

                hide_pid(pid_args.pid_start, pid_args.pid_end);
                break;
            }

            /* Unhide process */
            case 2:
            {
                struct pid_args pid_args;

                DEBUG("Unhiding process\n");

                if ( copy_from_user(&pid_args, buf, sizeof(pid_args)) )
                    return -EFAULT;

                unhide_pid(pid_args.pid_start, pid_args.pid_end);
                break;
            }

            /* Hide file */
            case 3:
            {
                char *name;
                struct file_args file_args;

                DEBUG("Hiding file\n");

                if ( copy_from_user(&file_args, buf, sizeof(file_args)) )
                    return -EFAULT;

                name = suckerusu_kmalloc(file_args.len + 1, GFP_KERNEL);
                if ( ZERO_OR_NULL_PTR(name) )
                    return -ENOMEM;

                ret = copy_from_user(name, file_args.name, file_args.len);
                if ( ret )
                {
                    suckerusu_kfree(name);
                    return -EFAULT;
                }

                name[file_args.len] = 0;

                hide_file(name);
                break;
            }

            /* Unhide file */
            case 4:
            {
                char *name;
                struct file_args file_args;

                DEBUG("Unhiding file\n");

                if ( copy_from_user(&file_args, buf, sizeof(file_args)) )
                    return -EFAULT;

                name = suckerusu_kmalloc(file_args.len + 1, GFP_KERNEL);
                if ( ZERO_OR_NULL_PTR(name) )
                    return -ENOMEM;

                ret = copy_from_user(name, file_args.name, file_args.len);
                if ( ret )
                {
                    suckerusu_kfree(name);
                    return -EFAULT;
                }

                name[file_args.len] = 0;

                unhide_file(name);
                break;
            }

            /* Toggle debugging */
            case 5:
            {
                debug = (long)buf;

                DEBUG("Debugging set to: %ld\n", debug);
            }
        }

        return ret;
    }

    return orig_sys_shmctl(shmid, cmd, (void *)buf);
}
```
但是单单看这个函数是找不出什么漏洞的。其实无论在内核还是用户态当有heap分配的时候，第一时刻要看看有没有UAF的洞。可能是很久没pwn用户态的题了，看这个题的代码时居然没想到UAF(也是经验不足~)。
在审计代码的时候我就想了下要在hidden_file这个结构体上下文章，因为源码中给出了提权函数，所以当时我想到的可能的思路是覆盖这个结构体里面的cb函数指针，因为下面的函数会执行这个cb函数。但是这题没有任意写或者部分写的漏洞，所以当时我就不知道咋办。
```c
static int hook_root_filldir( void *__buf, const char *name, int namelen, loff_t offset, u64 ino, unsigned d_type )
{
    struct hidden_file *hf;

    DEBUG("%s: enter, name=%s\n", __func__, name);

    list_for_each_entry ( hf, &hidden_files, list )
    {
        DEBUG("Checking name against: '%s' with callback %p\n", hf->name, hf->cb);

        if ( strstr(name, hf->name) )
        {
            DEBUG("Match!\n");

            if ( hf->cb )
                hf->cb(hf);   <=== attention here

            return 0;
        }
    }

    DEBUG("%s: end\n", __func__);

    return root_filldir(__buf, name, namelen, offset, ino, d_type);
}
```
heap的漏洞很多情况下是对释放的对象没有做相应的"析构"处理，例如指针清零等。但是这题的漏洞有点不同，看源码的以下代码：
```c
void unhide_pid ( long pid_start, long pid_end )
{
    struct hidden_pid *hp;

    list_for_each_entry ( hp, &hidden_pids, list )
    {
        if ( (pid_start == hp->pid_start) && (pid_end == hp->pid_end) )
        {
            list_del(&hp->list);
            suckerusu_kfree(hp);
            break;
        }
    }
}

void unhide_file ( char *name )
{
    struct hidden_file *hf;

    list_for_each_entry ( hf, &hidden_files, list )
    {
        if ( ! strcmp(name, hf->name) )
        {
            suckerusu_kfree(hf->name);
            suckerusu_kfree(hf);
            break;
        }
    }
}
```
看出异常没？unhide_file没有把hidden_file结构从链表中移除，就算你unhide file了，这个hidden_file结构还是在链表中，这就是个典型的UAF！但是即使想到这了貌似也不知道咋利用这个UAF的漏洞~
有个细节需要注意，看下面的代码：
```c
struct hidden_pid {
    long pid_start;
    long pid_end;
    struct list_head list;
};

struct hidden_file {
    void (*cb)(struct hidden_file *);
    char *name;
    struct list_head list;
};
```
这两个结构体的大小是一样的，而且布局结构都一样，是否可以混用？这时看看下面的代码：
```c
void hide_pid ( long pid_start, long pid_end )
{
    struct hidden_pid *hp;

    hp = suckerusu_kmalloc(sizeof(*hp), GFP_KERNEL);
    if ( ! hp )
        return;

    hp->pid_start = pid_start;
    hp->pid_end = pid_end;

    list_add(&hp->list, &hidden_pids);
}

void hide_file ( char *name )
{
    struct hidden_file *hf;

    hf = suckerusu_kmalloc(sizeof(*hf), GFP_KERNEL);
    if ( ! hf )
        return;

    hf->name = name;
    hf->cb = debug_hidden_file;

    list_add(&hf->list, &hidden_files);
}
```
这两个函数几乎是一模一样，如果我们把hp->pid_start赋值为up_up函数的地址，hp->pid_end赋值为name的地址，这就好似hidden_pid伪装成了hidden_file结构体了！这波骚操作，满分！

结合UAF的漏洞，先hide file，然后unhide file，这时内核分配的hidden_file结构被释放，但是这个结构体还是在hidden_files链表中。而且这一小块内存我们是有办法再次取回的，因为hidden_pid和hidden_file结构体的大小相等。我们可以分配大量的hidden_pid结构体来取回目标内存，并且如上所说在hidden_pid上做点文章，把up_up和name的地址赋给hp->pid_start和hp->pid_end(其实就是overwrite原来的cb指针了)。这时目标内存中的结构体就成了fake hidden_file，cb=&up_up，name字段的话保持不变。当执行hook_root_filldir时就会调用up_up函数，然后执行system("/bin/sh")就可以了。

最后一点需要注意的是文件名的问题，再看看下面的代码：
```c
static int hook_root_filldir( void *__buf, const char *name, int namelen, loff_t offset, u64 ino, unsigned d_type )
{
    struct hidden_file *hf;

    DEBUG("%s: enter, name=%s\n", __func__, name);

    list_for_each_entry ( hf, &hidden_files, list )
    {
        DEBUG("Checking name against: '%s' with callback %p\n", hf->name, hf->cb);

        if ( strstr(name, hf->name) ) [1]<== look here
        {
            DEBUG("Match!\n");

            if ( hf->cb )
                hf->cb(hf);

            return 0;
        }
    }

    DEBUG("%s: end\n", __func__);

    return root_filldir(__buf, name, namelen, offset, ino, d_type);
}
```
想让hf->name是name的子串在这里要么两者相等(就是说文件必须在相应目录下存在)，要么hf->name为空串。
现在所有问题都已经解决，思路也清晰了，接下来就是写exp了。

## Exploit
不知道为啥，exp在我的ubuntu 14.04(64 bit)中总导致死机~百思不得其解。
内核模块的函数地址可以通过读/proc/kallsyms文件获得。
steps to exploit：
1. get the address of up_up by /proc/kallsyms.
2. syscall(__NR_shmctl, AUTH_TOKEN, HIDE_FILE, &file_args), hidding file.
3. syscall(__NR_shmctl, AUTH_TOKEN, UNHIDE_FILE, &file_args), unhidding file.
4. syscall(__NR_shmctl, AUTH_TOKEN, HIDE_PID, &pid_args) many times, spraying pid objects.
5. opendir and readdir, triggering up_up and escalating privilege finished! 

